<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Equalizer: eq::Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Equalizer&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceeq.html">eq</a>      </li>
      <li class="navelem"><a class="el" href="classeq_1_1Image.html">Image</a>      </li>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>eq::Image Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="eq::Image" -->
<p>A holder for pixel data.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="image_8h_source.html">image.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png"/> Collaboration diagram for eq::Image:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classeq_1_1Image__coll__graph.png" border="0" usemap="#eq_1_1Image_coll__map" alt="Collaboration graph"/></div>
<map name="eq_1_1Image_coll__map" id="eq_1_1Image_coll__map">
<area shape="rect" id="node2" href="classeq_1_1fabric_1_1PixelViewport.html" title="Holds a 2D pixel viewport with methods for manipulation." alt="" coords="5,5,179,35"/><area shape="rect" id="node8" href="structeq_1_1PixelData.html" title="The pixel data structure manages the pixel information for images." alt="" coords="148,101,255,131"/><area shape="rect" id="node10" href="classco_1_1base_1_1NonCopyable.html" title="Base class to make objects non&#45;copyable." alt="" coords="212,5,380,35"/><area shape="rect" id="node13" href="classeq_1_1util_1_1Texture.html" title="A wrapper around OpenGL textures." alt="" coords="255,155,375,184"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classeq_1_1Image-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>Attachment</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>Memory</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ae200fb6218264228c0cd02ff841851c5">Image</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classeq_1_1Image.html" title="A holder for pixel data.">Image</a>.  <a href="#ae200fb6218264228c0cd02ff841851c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#af6efa63e83cee62096334ab0e56d654d">~Image</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the <a class="el" href="classeq_1_1Image.html" title="A holder for pixel data.">Image</a>.  <a href="#af6efa63e83cee62096334ab0e56d654d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Image parameters</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a200975ad1c0e40256dc98b04f558b382">setInternalFormat</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const uint32_t internalFormat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal format for the given buffer.  <a href="#a200975ad1c0e40256dc98b04f558b382"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ab0876d5dcb1ef818f995d418f71a9136">getInternalFormat</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a02d50003619bf83411e83488df4900ff">getExternalFormat</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the external format of the given buffer.  <a href="#a02d50003619bf83411e83488df4900ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ac67b8bc174feefec5ac1dbf3b3779f1c">getPixelSize</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, of one pixel in the external pixel data.  <a href="#ac67b8bc174feefec5ac1dbf3b3779f1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ad7d5a7298c213a4261c7e9a2de6ac1b6">hasAlpha</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#aca5a30a816550ac864f3fe1eb51201c5">setStorageType</a> (const <a class="el" href="classeq_1_1Frame.html#a35b1bad6ec7643a02fac270e9c6af30b">Frame::Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the frame pixel storage type.  <a href="#aca5a30a816550ac864f3fe1eb51201c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeq_1_1Frame.html#a35b1bad6ec7643a02fac270e9c6af30b">Frame::Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#afbb7de00f0e8ce5d7787f4e851fbf506">getStorageType</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ae88cb14d4315161f9b45fc37dba3e588">setPixelViewport</a> (const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;pvp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal pixel viewport of the image.  <a href="#ae88cb14d4315161f9b45fc37dba3e588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a89f479314f066b2c1b3f79937673a86c">getPixelViewport</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a6b577d1f9de4a6267b2f8eb6fe1b1302">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the image to its default state.  <a href="#a6b577d1f9de4a6267b2f8eb6fe1b1302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a182d54938ca4c74bffad68b769352090">flush</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all cached data of this image.  <a href="#a182d54938ca4c74bffad68b769352090"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Pixel Data Access</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a2ecc0c5a7b9360fd93c8e8b6c124051c">getPixelPointer</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a1b200026bfbe76d3a0b3dcefb89590d0">getPixelPointer</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ae0aa70d753e58fbde79b045d0ec86a2f">getPixelDataSize</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structeq_1_1PixelData.html">PixelData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a98ac7cd3a83cbfaac143e9906990fc4f">getPixelData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structeq_1_1PixelData.html">PixelData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a56003dc58152f53dc252f0a8d8fb63d6">compressPixelData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a6409c1b6f97390eb98185adfb1e2e2e1">hasPixelData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a534129f6ca72b069bda6178efe8139f7">clearPixelData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear and validate an image buffer.  <a href="#a534129f6ca72b069bda6178efe8139f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#aabab1397db5fcbc47beb07b13df5999d">validatePixelData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an image buffer without initialization.  <a href="#aabab1397db5fcbc47beb07b13df5999d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a6407b19c13df8b8fdb5e8e419583cf0a">setPixelData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const <a class="el" href="structeq_1_1PixelData.html">PixelData</a> &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the pixel data of the given image buffer.  <a href="#a6407b19c13df8b8fdb5e8e419583cf0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a717e3536573a8a09b361c29e6022107f">setAlphaUsage</a> (const bool enabled)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set alpha data preservation during download and compression.  <a href="#a717e3536573a8a09b361c29e6022107f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ac054000d9096aa6905c287edc1577cdd">getAlphaUsage</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#adee5df3cdbe3c26fe047b3fb8a0d723a">setQuality</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const float quality)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum quality after a full download-compression path.  <a href="#adee5df3cdbe3c26fe047b3fb8a0d723a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a10a764afdba9bb1ffdbc8e2c9d123d9d">getQuality</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture Data Access</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classeq_1_1util_1_1Texture.html">util::Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a7a79c3baebeafe8fa28647de30bc11e4">getTexture</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the texture of this image.  <a href="#a7a79c3baebeafe8fa28647de30bc11e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a08a18a18d371fe57d23c92fe6d0db198">hasTextureData</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Operations</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ad21730ba96c53c37779b02b3bdda8105">readback</a> (const uint32_t buffers, const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;pvp, const <a class="el" href="classeq_1_1fabric_1_1Zoom.html">Zoom</a> &amp;zoom, <a class="el" href="classeq_1_1util_1_1ObjectManager.html">util::ObjectManager</a>&lt; const void * &gt; *glObjects)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read back an image from the frame buffer.  <a href="#ad21730ba96c53c37779b02b3bdda8105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a687f0b240502e46ddbdea59e55fe8fda"></a><!-- doxytag: member="eq::Image::readback" ref="a687f0b240502e46ddbdea59e55fe8fda" args="(const Frame::Buffer buffer, const util::Texture *texture, const GLEWContext *glewContext)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readback</b> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const <a class="el" href="classeq_1_1util_1_1Texture.html">util::Texture</a> *texture, const GLEWContext *glewContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#a2005aedb42b4d8ad69b9a36dd2143a72">upload</a> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, <a class="el" href="classeq_1_1util_1_1Texture.html">util::Texture</a> *texture, const <a class="el" href="namespaceeq.html#ac59bc89fc06eaca251d16162693f09ac">Vector2i</a> &amp;position, <a class="el" href="classeq_1_1util_1_1ObjectManager.html">util::ObjectManager</a>&lt; const void * &gt; *glObjects) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload this image to the frame buffer or a texture.  <a href="#a2005aedb42b4d8ad69b9a36dd2143a72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#aba1eb4da499d315e2c026a05509b3e9f">writeImage</a> (const std::string &amp;filename, const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the pixel data as rgb image file.  <a href="#aba1eb4da499d315e2c026a05509b3e9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ac488392c409330f193070cdf88cfd0a8">writeImages</a> (const std::string &amp;filenameTemplate) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all valid pixel data as separate images.  <a href="#ac488392c409330f193070cdf88cfd0a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Image.html#ab400e79911baf5807dbdfd7f1b5e5d73">readImage</a> (const std::string &amp;filename, const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read pixel data from an uncompressed rgb image file.  <a href="#ab400e79911baf5807dbdfd7f1b5e5d73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60606d06a6885a21381c3150a89230cf"></a><!-- doxytag: member="eq::Image::setOffset" ref="a60606d06a6885a21381c3150a89230cf" args="(int32_t x, int32_t y)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>setOffset</b> (int32_t x, int32_t y)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2582c58bd815bebab477cf07627e4f65"></a><!-- doxytag: member="eq::Image::findCompressors" ref="a2582c58bd815bebab477cf07627e4f65" args="(const Frame::Buffer buffer) const " -->
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>findCompressors</b> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd0194ac4a0e3719b4973d52435c96f9"></a><!-- doxytag: member="eq::Image::findTransferers" ref="abd0194ac4a0e3719b4973d52435c96f9" args="(const Frame::Buffer buffer, const GLEWContext *glewContext, std::vector&lt; uint32_t &gt; &amp;names)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>findTransferers</b> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const GLEWContext *glewContext, std::vector&lt; uint32_t &gt; &amp;names)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1231fcc8eb73148b544465795862a32"></a><!-- doxytag: member="eq::Image::allocCompressor" ref="af1231fcc8eb73148b544465795862a32" args="(const Frame::Buffer buffer, const uint32_t name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allocCompressor</b> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const uint32_t name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1f3dab4e35f8499e05463108ef14242"></a><!-- doxytag: member="eq::Image::allocDownloader" ref="af1f3dab4e35f8499e05463108ef14242" args="(const Frame::Buffer buffer, const uint32_t name, const GLEWContext *glewContext)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allocDownloader</b> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer, const uint32_t name, const GLEWContext *glewContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b2685459187c9408f166b8fb725a3c8"></a><!-- doxytag: member="eq::Image::getDownloaderName" ref="a4b2685459187c9408f166b8fb725a3c8" args="(const Frame::Buffer buffer) const " -->
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getDownloaderName</b> (const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a> buffer) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A holder for pixel data. </p>
<p>An image holds color and depth information for one rectangular region. </p>

<p>Definition at line <a class="el" href="image_8h_source.html#l00042">42</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae200fb6218264228c0cd02ff841851c5"></a><!-- doxytag: member="eq::Image::Image" ref="ae200fb6218264228c0cd02ff841851c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">eq::Image::Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new <a class="el" href="classeq_1_1Image.html" title="A holder for pixel data.">Image</a>. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="af6efa63e83cee62096334ab0e56d654d"></a><!-- doxytag: member="eq::Image::~Image" ref="af6efa63e83cee62096334ab0e56d654d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual eq::Image::~Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destruct the <a class="el" href="classeq_1_1Image.html" title="A holder for pixel data.">Image</a>. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a534129f6ca72b069bda6178efe8139f7"></a><!-- doxytag: member="eq::Image::clearPixelData" ref="a534129f6ca72b069bda6178efe8139f7" args="(const Frame::Buffer buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::clearPixelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear and validate an image buffer. </p>
<p>RGBA and BGRA buffers are initialized with (0,0,0,255). DEPTH_UNSIGNED_INT buffers are initialized with 255. All other buffers are zero-initialized. Validates the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the image buffer to clear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a56003dc58152f53dc252f0a8d8fb63d6"></a><!-- doxytag: member="eq::Image::compressPixelData" ref="a56003dc58152f53dc252f0a8d8fb63d6" args="(const Frame::Buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structeq_1_1PixelData.html">PixelData</a>&amp; eq::Image::compressPixelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the pixel data, compressing it if needed. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a182d54938ca4c74bffad68b769352090"></a><!-- doxytag: member="eq::Image::flush" ref="a182d54938ca4c74bffad68b769352090" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all cached data of this image. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac054000d9096aa6905c287edc1577cdd"></a><!-- doxytag: member="eq::Image::getAlphaUsage" ref="ac054000d9096aa6905c287edc1577cdd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::getAlphaUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if alpha data can not be ignored. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00211">211</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a02d50003619bf83411e83488df4900ff"></a><!-- doxytag: member="eq::Image::getExternalFormat" ref="a02d50003619bf83411e83488df4900ff" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t eq::Image::getExternalFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the external format of the given buffer. </p>
<p>The external format describes the layout of the pixel data in main memory. It is determined by the plugin used during download. The external format also determines the pixel size and alpha availability.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the frame buffer attachment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the external format of the pixel data. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00083">83</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0876d5dcb1ef818f995d418f71a9136"></a><!-- doxytag: member="eq::Image::getInternalFormat" ref="ab0876d5dcb1ef818f995d418f71a9136" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t eq::Image::getInternalFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the internal format of the pixel data. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a98ac7cd3a83cbfaac143e9906990fc4f"></a><!-- doxytag: member="eq::Image::getPixelData" ref="a98ac7cd3a83cbfaac143e9906990fc4f" args="(const Frame::Buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structeq_1_1PixelData.html">PixelData</a>&amp; eq::Image::getPixelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the pixel data. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae0aa70d753e58fbde79b045d0ec86a2f"></a><!-- doxytag: member="eq::Image::getPixelDataSize" ref="ae0aa70d753e58fbde79b045d0ec86a2f" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t eq::Image::getPixelDataSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the total size of the pixel data in bytes. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2ecc0c5a7b9360fd93c8e8b6c124051c"></a><!-- doxytag: member="eq::Image::getPixelPointer" ref="a2ecc0c5a7b9360fd93c8e8b6c124051c" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* eq::Image::getPixelPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the raw pixel data. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a1b200026bfbe76d3a0b3dcefb89590d0"></a><!-- doxytag: member="eq::Image::getPixelPointer" ref="a1b200026bfbe76d3a0b3dcefb89590d0" args="(const Frame::Buffer buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* eq::Image::getPixelPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the raw pixel data. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac67b8bc174feefec5ac1dbf3b3779f1c"></a><!-- doxytag: member="eq::Image::getPixelSize" ref="ac67b8bc174feefec5ac1dbf3b3779f1c" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t eq::Image::getPixelSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size, in bytes, of one pixel in the external pixel data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the frame buffer attachment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classeq_1_1Image.html#a02d50003619bf83411e83488df4900ff" title="Get the external format of the given buffer.">getExternalFormat()</a> </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00093">93</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89f479314f066b2c1b3f79937673a86c"></a><!-- doxytag: member="eq::Image::getPixelViewport" ref="a89f479314f066b2c1b3f79937673a86c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a>&amp; eq::Image::getPixelViewport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the internal pixel viewport. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00133">133</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a10a764afdba9bb1ffdbc8e2c9d123d9d"></a><!-- doxytag: member="eq::Image::getQuality" ref="a10a764afdba9bb1ffdbc8e2c9d123d9d" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float eq::Image::getQuality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the minimum quality. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="afbb7de00f0e8ce5d7787f4e851fbf506"></a><!-- doxytag: member="eq::Image::getStorageType" ref="afbb7de00f0e8ce5d7787f4e851fbf506" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeq_1_1Frame.html#a35b1bad6ec7643a02fac270e9c6af30b">Frame::Type</a> eq::Image::getStorageType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the pixel data storage type. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00117">117</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a79c3baebeafe8fa28647de30bc11e4"></a><!-- doxytag: member="eq::Image::getTexture" ref="a7a79c3baebeafe8fa28647de30bc11e4" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classeq_1_1util_1_1Texture.html">util::Texture</a>&amp; eq::Image::getTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the texture of this image. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad7d5a7298c213a4261c7e9a2de6ac1b6"></a><!-- doxytag: member="eq::Image::hasAlpha" ref="ad7d5a7298c213a4261c7e9a2de6ac1b6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::hasAlpha </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the image has a color buffer with alpha values. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classeq_1_1Image.html#a02d50003619bf83411e83488df4900ff" title="Get the external format of the given buffer.">getExternalFormat()</a> </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6409c1b6f97390eb98185adfb1e2e2e1"></a><!-- doxytag: member="eq::Image::hasPixelData" ref="a6409c1b6f97390eb98185adfb1e2e2e1" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::hasPixelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the image has valid pixel data for the buffer. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00172">172</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a08a18a18d371fe57d23c92fe6d0db198"></a><!-- doxytag: member="eq::Image::hasTextureData" ref="a08a18a18d371fe57d23c92fe6d0db198" args="(const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::hasTextureData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the image has texture data for the buffer. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ad21730ba96c53c37779b02b3bdda8105"></a><!-- doxytag: member="eq::Image::readback" ref="ad21730ba96c53c37779b02b3bdda8105" args="(const uint32_t buffers, const PixelViewport &amp;pvp, const Zoom &amp;zoom, util::ObjectManager&lt; const void * &gt; *glObjects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::readback </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;&#160;</td>
          <td class="paramname"><em>pvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeq_1_1fabric_1_1Zoom.html">Zoom</a> &amp;&#160;</td>
          <td class="paramname"><em>zoom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1util_1_1ObjectManager.html">util::ObjectManager</a>&lt; const void * &gt; *&#160;</td>
          <td class="paramname"><em>glObjects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read back an image from the frame buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>bit-wise combination of the <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151" title="The buffer format defines which components of the frame are to be used during readback and assembly...">Frame::Buffer</a> components. </td></tr>
    <tr><td class="paramname">pvp</td><td>the area of the frame buffer wrt the drawable. </td></tr>
    <tr><td class="paramname">zoom</td><td>the scale factor to apply during readback. </td></tr>
    <tr><td class="paramname">glObjects</td><td>the GL object manager for the current GL context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true when data was read back, false on error. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ab400e79911baf5807dbdfd7f1b5e5d73"></a><!-- doxytag: member="eq::Image::readImage" ref="ab400e79911baf5807dbdfd7f1b5e5d73" args="(const std::string &amp;filename, const Frame::Buffer buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::readImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read pixel data from an uncompressed rgb image file. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6b577d1f9de4a6267b2f8eb6fe1b1302"></a><!-- doxytag: member="eq::Image::reset" ref="a6b577d1f9de4a6267b2f8eb6fe1b1302" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the image to its default state. </p>
<p>This method does not free allocated memory or plugins. Invalidates all pixel data.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classeq_1_1Image.html#a182d54938ca4c74bffad68b769352090" title="Free all cached data of this image.">flush()</a> </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a717e3536573a8a09b361c29e6022107f"></a><!-- doxytag: member="eq::Image::setAlphaUsage" ref="a717e3536573a8a09b361c29e6022107f" args="(const bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::setAlphaUsage </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set alpha data preservation during download and compression. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a200975ad1c0e40256dc98b04f558b382"></a><!-- doxytag: member="eq::Image::setInternalFormat" ref="a200975ad1c0e40256dc98b04f558b382" args="(const Frame::Buffer buffer, const uint32_t internalFormat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::setInternalFormat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>internalFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the internal format for the given buffer. </p>
<p>The internal format descibes the format of the pixel data source, typically an OpenGL frame buffer or texture. The internal formats used by Equalizer use the same numerical value as their OpenGL counterpart.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the frame buffer attachment. </td></tr>
    <tr><td class="paramname">internalFormat</td><td>the internal format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a6407b19c13df8b8fdb5e8e419583cf0a"></a><!-- doxytag: member="eq::Image::setPixelData" ref="a6407b19c13df8b8fdb5e8e419583cf0a" args="(const Frame::Buffer buffer, const PixelData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::setPixelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeq_1_1PixelData.html">PixelData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the pixel data of the given image buffer. </p>
<p>Previous data for the buffer is overwritten. Validates the buffer. Depending on the given <a class="el" href="structeq_1_1PixelData.html" title="The pixel data structure manages the pixel information for images.">PixelData</a> parameters, the pixel data is copied, decompressed or cleared.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the image buffer to set. </td></tr>
    <tr><td class="paramname">data</td><td>the pixel data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae88cb14d4315161f9b45fc37dba3e588"></a><!-- doxytag: member="eq::Image::setPixelViewport" ref="ae88cb14d4315161f9b45fc37dba3e588" args="(const PixelViewport &amp;pvp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::setPixelViewport </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;&#160;</td>
          <td class="paramname"><em>pvp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the internal pixel viewport of the image. </p>
<p>The image pixel data and textures will be invalidated. The pixel data describes the size of the image on the destination (GPU). Each downloaded buffer has its own size, which is potentially different from the image PVP.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pvp</td><td>the pixel viewport. </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="adee5df3cdbe3c26fe047b3fb8a0d723a"></a><!-- doxytag: member="eq::Image::setQuality" ref="adee5df3cdbe3c26fe047b3fb8a0d723a" args="(const Frame::Buffer buffer, const float quality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::setQuality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the minimum quality after a full download-compression path. </p>
<p>The automatic selection of a download and compression plugin will never always choose plugins which maintain at least the given quality. A quality of 1.0 enables a lossless transmission path, and a quality of 0.0 disables all quality quarantees.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the frame buffer attachment. </td></tr>
    <tr><td class="paramname">quality</td><td>the minimum quality to maintain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aca5a30a816550ac864f3fe1eb51201c5"></a><!-- doxytag: member="eq::Image::setStorageType" ref="aca5a30a816550ac864f3fe1eb51201c5" args="(const Frame::Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::setStorageType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a35b1bad6ec7643a02fac270e9c6af30b">Frame::Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the frame pixel storage type. </p>
<p>Images of storage type TYPE_MEMORY are read back from the frame buffer into main memory using a transfer plugin. The data can be accessed through the <a class="el" href="structeq_1_1PixelData.html" title="The pixel data structure manages the pixel information for images.">PixelData</a>.</p>
<p><a class="el" href="classeq_1_1Image.html" title="A holder for pixel data.">Image</a> of storage type TYPE_TEXTURE read frame buffer data into a texture, which can be accessed using <a class="el" href="classeq_1_1Image.html#a7a79c3baebeafe8fa28647de30bc11e4" title="Get the texture of this image.">getTexture()</a>. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Definition at line <a class="el" href="image_8h_source.html#l00114">114</a> of file <a class="el" href="image_8h_source.html">image.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2005aedb42b4d8ad69b9a36dd2143a72"></a><!-- doxytag: member="eq::Image::upload" ref="a2005aedb42b4d8ad69b9a36dd2143a72" args="(const Frame::Buffer buffer, util::Texture *texture, const Vector2i &amp;position, util::ObjectManager&lt; const void * &gt; *glObjects) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::upload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1util_1_1Texture.html">util::Texture</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#ac59bc89fc06eaca251d16162693f09ac">Vector2i</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1util_1_1ObjectManager.html">util::ObjectManager</a>&lt; const void * &gt; *&#160;</td>
          <td class="paramname"><em>glObjects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Upload this image to the frame buffer or a texture. </p>
<p>If a texture is given, the upload is performed to the it. Otherwise the pixel data is uploaded to the frame buffer. The texture will be initialized using the parameters corresponding to the requested buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the buffer type. </td></tr>
    <tr><td class="paramname">texture</td><td>the target texture, or 0 for frame buffer upload. </td></tr>
    <tr><td class="paramname">position</td><td>the destination offset wrt current GL viewport. </td></tr>
    <tr><td class="paramname">glObjects</td><td>the OpenGL object manager for the current context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aabab1397db5fcbc47beb07b13df5999d"></a><!-- doxytag: member="eq::Image::validatePixelData" ref="aabab1397db5fcbc47beb07b13df5999d" args="(const Frame::Buffer buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void eq::Image::validatePixelData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an image buffer without initialization. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="aba1eb4da499d315e2c026a05509b3e9f"></a><!-- doxytag: member="eq::Image::writeImage" ref="aba1eb4da499d315e2c026a05509b3e9f" args="(const std::string &amp;filename, const Frame::Buffer buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::writeImage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html#a6740f57d1cd10e9801537262d703c151">Frame::Buffer</a>&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the pixel data as rgb image file. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="ac488392c409330f193070cdf88cfd0a8"></a><!-- doxytag: member="eq::Image::writeImages" ref="ac488392c409330f193070cdf88cfd0a8" args="(const std::string &amp;filenameTemplate) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool eq::Image::writeImages </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filenameTemplate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write all valid pixel data as separate images. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="image_8h_source.html">image.h</a></li>
</ul>
</div>
<address style="text-align: right;">
  <small>Generated on Sun May 8 2011 19:11:09 for 
    <a href="/index.html"><img src="/images/Equalizer-doxygen.png" 
                               alt="Equalizer" align="middle" 
                               border="0"></a> 1.0 by&nbsp;
    <a href="http://www.doxygen.org/index.html">
      <img src="doxygen.png" alt="doxygen" align="middle" border="0">
    </a> 1.7.3 
  </small>
</address>
</body>
</html>

