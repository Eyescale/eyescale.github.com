<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Equalizer: eq::Compositor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Equalizer&#160;<span id="projectnumber">1.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceeq.html">eq</a>      </li>
      <li class="navelem"><a class="el" href="classeq_1_1Compositor.html">Compositor</a>      </li>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<h1>eq::Compositor Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="eq::Compositor" -->
<p>A set of functions performing compositing for a set of input frames.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="compositor_8h_source.html">compositor.h</a>&gt;</code></p>

<p><a href="classeq_1_1Compositor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure describing an image assembly task.  <a href="structeq_1_1Compositor_1_1ImageOp.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Frame-based operations.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a8a0b77067d7d37dfd108de28c5ac58c2">assembleFrames</a> (const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;frames, <a class="el" href="classeq_1_1Channel.html">Channel</a> *channel, <a class="el" href="classeq_1_1util_1_1Accum.html">util::Accum</a> *accum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble all frames in an arbitrary order using the fastest implemented algorithm on the given channel.  <a href="#a8a0b77067d7d37dfd108de28c5ac58c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a9002afd3ed306344123124cd504ec2fb">assembleFramesSorted</a> (const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;frames, <a class="el" href="classeq_1_1Channel.html">Channel</a> *channel, <a class="el" href="classeq_1_1util_1_1Accum.html">util::Accum</a> *accum, const bool blendAlpha=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble all frames in the given order using the fastest implemented algorithm on the given channel.  <a href="#a9002afd3ed306344123124cd504ec2fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a58197472aea059c279ab715b754360ae">assembleFramesUnsorted</a> (const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;frames, <a class="el" href="classeq_1_1Channel.html">Channel</a> *channel, <a class="el" href="classeq_1_1util_1_1Accum.html">util::Accum</a> *accum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble all frames in the order they become available directly on the given channel.  <a href="#a58197472aea059c279ab715b754360ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#acf83f2a026b8b86620c3689108c235e3">assembleFramesCPU</a> (const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;frames, <a class="el" href="classeq_1_1Channel.html">Channel</a> *channel, const bool blendAlpha=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble all frames in the given order in a memory buffer using the CPU before assembling the result on the given channel.  <a href="#acf83f2a026b8b86620c3689108c235e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classeq_1_1Image.html">Image</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a2876503c1f3322547cffbea3538376da">mergeFramesCPU</a> (const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;frames, const bool blendAlpha=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the provided frames in the given order into one image in main memory.  <a href="#a2876503c1f3322547cffbea3538376da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#ad57ebb52d7035961a4c03ecea5e3f569">mergeFramesCPU</a> (const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;frames, const bool blendAlpha, void *colorBuffer, const uint32_t colorBufferSize, void *depthBuffer, const uint32_t depthBufferSize, <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;outPVP)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the provided frames into one main memory buffer.  <a href="#ad57ebb52d7035961a4c03ecea5e3f569"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#ae94eb1d782b17d82191e06a8f46fd6c3">assembleFrame</a> (const <a class="el" href="classeq_1_1Frame.html">Frame</a> *frame, <a class="el" href="classeq_1_1Channel.html">Channel</a> *channel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble a frame into the frame buffer using the default algorithm.  <a href="#ae94eb1d782b17d82191e06a8f46fd6c3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Image-based operations.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a8da8b24ed7e099443cb06ff0c699c011">assembleImage</a> (const <a class="el" href="classeq_1_1Image.html">Image</a> *image, const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;operation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble an image into the frame buffer.  <a href="#a8da8b24ed7e099443cb06ff0c699c011"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a213c1d2dc0662564806fae00b560fcd0">setupStencilBuffer</a> (const <a class="el" href="classeq_1_1Image.html">Image</a> *image, const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;operation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the stencil buffer for a pixel compound recomposition.  <a href="#a213c1d2dc0662564806fae00b560fcd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#aad0541a100a8ad26a9ab021d4708c72a">clearStencilBuffer</a> (const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;operation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil buffer after a pixel compound recomposition.  <a href="#aad0541a100a8ad26a9ab021d4708c72a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a4868cd046149e1903193f51f55f99249">setupAssemblyState</a> (const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;pvp, const GLEWContext *gl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup the OpenGL state.  <a href="#a4868cd046149e1903193f51f55f99249"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab188dfdd905dcdf208b2d24dd64378f1"></a><!-- doxytag: member="eq::Compositor::resetAssemblyState" ref="ab188dfdd905dcdf208b2d24dd64378f1" args="()" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#ab188dfdd905dcdf208b2d24dd64378f1">resetAssemblyState</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the OpenGL state. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a31bdda17079d729007bad3190e250330">assembleImage2D</a> (const <a class="el" href="classeq_1_1Image.html">Image</a> *image, const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a tile-based assembly of the image color attachment.  <a href="#a31bdda17079d729007bad3190e250330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a88bc77090210c2da92bf46f18b0b2f71">assembleImageDB</a> (const <a class="el" href="classeq_1_1Image.html">Image</a> *image, const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Z-based assembly of the image color and depth attachment.  <a href="#a88bc77090210c2da92bf46f18b0b2f71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4fe4a778e57d9c519f3b27fcc5c235a"></a><!-- doxytag: member="eq::Compositor::assembleImageDB_FF" ref="ae4fe4a778e57d9c519f3b27fcc5c235a" args="(const Image *image, const ImageOp &amp;op)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#ae4fe4a778e57d9c519f3b27fcc5c235a">assembleImageDB_FF</a> (const <a class="el" href="classeq_1_1Image.html">Image</a> *image, const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Z-based assembly of the image color and depth attachment, based on OpenGL 1.1 functionality. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639f5ea106298d8b91889280fd7f48fc"></a><!-- doxytag: member="eq::Compositor::assembleImageDB_GLSL" ref="a639f5ea106298d8b91889280fd7f48fc" args="(const Image *image, const ImageOp &amp;op)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeq_1_1Compositor.html#a639f5ea106298d8b91889280fd7f48fc">assembleImageDB_GLSL</a> (const <a class="el" href="classeq_1_1Image.html">Image</a> *image, const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;op)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a Z-based assembly of the image color and depth attachment, using GLSL. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A set of functions performing compositing for a set of input frames. </p>
<p>The following diagram depicts the call flow within the compositor. Typically, an application uses one of the entry functions <a class="el" href="classeq_1_1Compositor.html#a8a0b77067d7d37dfd108de28c5ac58c2" title="Assemble all frames in an arbitrary order using the fastest implemented algorithm on the given channe...">assembleFrames()</a> or <a class="el" href="classeq_1_1Compositor.html#a58197472aea059c279ab715b754360ae" title="Assemble all frames in the order they become available directly on the given channel.">assembleFramesUnsorted()</a>, but the various lower-level functions are still useful for advanced tasks, e.g., <a class="el" href="classeq_1_1Compositor.html#a2876503c1f3322547cffbea3538376da" title="Merge the provided frames in the given order into one image in main memory.">mergeFramesCPU()</a> to perform compositing on the CPU into a main memory buffer.</p>
<div align="center">
<img src="http://www.equalizergraphics.com/documents/design/images/compositor.png" alt="compositor.png"/>
</div>
 
<p>Definition at line <a class="el" href="compositor_8h_source.html#l00048">48</a> of file <a class="el" href="compositor_8h_source.html">compositor.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae94eb1d782b17d82191e06a8f46fd6c3"></a><!-- doxytag: member="eq::Compositor::assembleFrame" ref="ae94eb1d782b17d82191e06a8f46fd6c3" args="(const Frame *frame, Channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::assembleFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1Channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble a frame into the frame buffer using the default algorithm. </p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8a0b77067d7d37dfd108de28c5ac58c2"></a><!-- doxytag: member="eq::Compositor::assembleFrames" ref="a8a0b77067d7d37dfd108de28c5ac58c2" args="(const Frames &amp;frames, Channel *channel, util::Accum *accum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t eq::Compositor::assembleFrames </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1Channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1util_1_1Accum.html">util::Accum</a> *&#160;</td>
          <td class="paramname"><em>accum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble all frames in an arbitrary order using the fastest implemented algorithm on the given channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>the frames to assemble. </td></tr>
    <tr><td class="paramname">channel</td><td>the destination channel. </td></tr>
    <tr><td class="paramname">accum</td><td>the accumulation buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of different subpixel steps assembled. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

<p>Referenced by <a class="el" href="classeqPly_1_1Channel.html#af026e7f43de551028bfc6f25afba005d">eqPly::Channel::frameAssemble()</a>.</p>

<p><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png"/> Here is the caller graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classeq_1_1Compositor_a8a0b77067d7d37dfd108de28c5ac58c2_icgraph.png" border="0" usemap="#classeq_1_1Compositor_a8a0b77067d7d37dfd108de28c5ac58c2_icgraph" alt=""/></div>
<map name="classeq_1_1Compositor_a8a0b77067d7d37dfd108de28c5ac58c2_icgraph" id="classeq_1_1Compositor_a8a0b77067d7d37dfd108de28c5ac58c2_icgraph">
<area shape="rect" id="node3" href="classeqPly_1_1Channel.html#af026e7f43de551028bfc6f25afba005d" title="Assemble all input frames." alt="" coords="295,5,519,35"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acf83f2a026b8b86620c3689108c235e3"></a><!-- doxytag: member="eq::Compositor::assembleFramesCPU" ref="acf83f2a026b8b86620c3689108c235e3" args="(const Frames &amp;frames, Channel *channel, const bool blendAlpha=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t eq::Compositor::assembleFramesCPU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1Channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blendAlpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble all frames in the given order in a memory buffer using the CPU before assembling the result on the given channel. </p>
<p>If alpha-blending is enabled, the images are blended into the intermediate image in main memory as if using: glBlendFuncSeparate( GL_ONE, GL_SRC_ALPHA, GL_ZERO, GL_SRC_ALPHA ) The resulting image is composited using glBlendFunc( GL_ONE, GL_SRC_ALPHA ) into the current framebuffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>the frames to assemble. </td></tr>
    <tr><td class="paramname">channel</td><td>the destination channel. </td></tr>
    <tr><td class="paramname">blendAlpha</td><td>blend color-only images if they have an alpha channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of different subpixel steps assembled (0 or 1). </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a9002afd3ed306344123124cd504ec2fb"></a><!-- doxytag: member="eq::Compositor::assembleFramesSorted" ref="a9002afd3ed306344123124cd504ec2fb" args="(const Frames &amp;frames, Channel *channel, util::Accum *accum, const bool blendAlpha=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t eq::Compositor::assembleFramesSorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1Channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1util_1_1Accum.html">util::Accum</a> *&#160;</td>
          <td class="paramname"><em>accum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blendAlpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble all frames in the given order using the fastest implemented algorithm on the given channel. </p>
<p>For alpha-blending see comment for <a class="el" href="classeq_1_1Compositor.html#acf83f2a026b8b86620c3689108c235e3" title="Assemble all frames in the given order in a memory buffer using the CPU before assembling the result ...">assembleFramesCPU()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>the frames to assemble. </td></tr>
    <tr><td class="paramname">channel</td><td>the destination channel. </td></tr>
    <tr><td class="paramname">accum</td><td>the accumulation buffer. </td></tr>
    <tr><td class="paramname">blendAlpha</td><td>blend color-only images if they have an alpha channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of different subpixel steps assembled. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a58197472aea059c279ab715b754360ae"></a><!-- doxytag: member="eq::Compositor::assembleFramesUnsorted" ref="a58197472aea059c279ab715b754360ae" args="(const Frames &amp;frames, Channel *channel, util::Accum *accum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t eq::Compositor::assembleFramesUnsorted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1Channel.html">Channel</a> *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1util_1_1Accum.html">util::Accum</a> *&#160;</td>
          <td class="paramname"><em>accum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble all frames in the order they become available directly on the given channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>the frames to assemble. </td></tr>
    <tr><td class="paramname">channel</td><td>the destination channel. </td></tr>
    <tr><td class="paramname">accum</td><td>the accumulation buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of different subpixel steps assembled. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a8da8b24ed7e099443cb06ff0c699c011"></a><!-- doxytag: member="eq::Compositor::assembleImage" ref="a8da8b24ed7e099443cb06ff0c699c011" args="(const Image *image, const ImageOp &amp;operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::assembleImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assemble an image into the frame buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the input image. </td></tr>
    <tr><td class="paramname">operation</td><td>an <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html" title="A structure describing an image assembly task.">ImageOp</a> struct describing the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31bdda17079d729007bad3190e250330"></a><!-- doxytag: member="eq::Compositor::assembleImage2D" ref="a31bdda17079d729007bad3190e250330" args="(const Image *image, const ImageOp &amp;op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::assembleImage2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a tile-based assembly of the image color attachment. </p>

</div>
</div>
<a class="anchor" id="a88bc77090210c2da92bf46f18b0b2f71"></a><!-- doxytag: member="eq::Compositor::assembleImageDB" ref="a88bc77090210c2da92bf46f18b0b2f71" args="(const Image *image, const ImageOp &amp;op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::assembleImageDB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a Z-based assembly of the image color and depth attachment. </p>

</div>
</div>
<a class="anchor" id="aad0541a100a8ad26a9ab021d4708c72a"></a><!-- doxytag: member="eq::Compositor::clearStencilBuffer" ref="aad0541a100a8ad26a9ab021d4708c72a" args="(const ImageOp &amp;operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::clearStencilBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the stencil buffer after a pixel compound recomposition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>the assembly parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad57ebb52d7035961a4c03ecea5e3f569"></a><!-- doxytag: member="eq::Compositor::mergeFramesCPU" ref="ad57ebb52d7035961a4c03ecea5e3f569" args="(const Frames &amp;frames, const bool blendAlpha, void *colorBuffer, const uint32_t colorBufferSize, void *depthBuffer, const uint32_t depthBufferSize, PixelViewport &amp;outPVP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool eq::Compositor::mergeFramesCPU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blendAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>colorBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>colorBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>depthBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>depthBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;&#160;</td>
          <td class="paramname"><em>outPVP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge the provided frames into one main memory buffer. </p>
<p>The callee has to allocate and clear (if needed) the output buffers to hold the necessary data. All input images have to use the same format and type, which will also be the output format. The depth buffer and depth buffer size may be 0, if the images contain no depth information.</p>
<p>The output pixel viewport receives the image size and offset wrt the destination channel.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the compositing was successful, false otherwise, e.g., a buffer is too small. </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a2876503c1f3322547cffbea3538376da"></a><!-- doxytag: member="eq::Compositor::mergeFramesCPU" ref="a2876503c1f3322547cffbea3538376da" args="(const Frames &amp;frames, const bool blendAlpha=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classeq_1_1Image.html">Image</a>* eq::Compositor::mergeFramesCPU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeq.html#a9577b0b3a00e66076dcb3fcf41592e52">Frames</a> &amp;&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>blendAlpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge the provided frames in the given order into one image in main memory. </p>
<p>The returned image does not have to be freed. The compositor maintains one image per thread, that is, the returned image is valid until the next usage of the compositor in the current thread.</p>
<dl class="version"><dt><b>Version:</b></dt><dd>1.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a4868cd046149e1903193f51f55f99249"></a><!-- doxytag: member="eq::Compositor::setupAssemblyState" ref="a4868cd046149e1903193f51f55f99249" args="(const PixelViewport &amp;pvp, const GLEWContext *gl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::setupAssemblyState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1fabric_1_1PixelViewport.html">PixelViewport</a> &amp;&#160;</td>
          <td class="paramname"><em>pvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLEWContext *&#160;</td>
          <td class="paramname"><em>gl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup the OpenGL state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pvp</td><td>the current pixel viewport. </td></tr>
    <tr><td class="paramname">gl</td><td>the OpenGL function table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a213c1d2dc0662564806fae00b560fcd0"></a><!-- doxytag: member="eq::Compositor::setupStencilBuffer" ref="a213c1d2dc0662564806fae00b560fcd0" args="(const Image *image, const ImageOp &amp;operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void eq::Compositor::setupStencilBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeq_1_1Image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeq_1_1Compositor_1_1ImageOp.html">ImageOp</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup the stencil buffer for a pixel compound recomposition. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image to be assembled. </td></tr>
    <tr><td class="paramname">operation</td><td>the assembly parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="compositor_8h_source.html">compositor.h</a></li>
</ul>
</div>
<address style="text-align: right;">
  <small>Generated on Sun May 8 2011 19:11:09 for 
    <a href="/index.html"><img src="/images/Equalizer-doxygen.png" 
                               alt="Equalizer" align="middle" 
                               border="0"></a> 1.0 by&nbsp;
    <a href="http://www.doxygen.org/index.html">
      <img src="doxygen.png" alt="doxygen" align="middle" border="0">
    </a> 1.7.3 
  </small>
</address>
</body>
</html>

