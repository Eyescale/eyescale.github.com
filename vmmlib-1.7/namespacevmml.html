<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vmmlib: vmml Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vmmlib
   &#160;<span id="projectnumber">1.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacevmml.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vmml Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>a wrapper for blas's daxpy routine.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1blas__daxpy.html">blas_daxpy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1blas__dgemm.html">blas_dgemm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1blas__dot.html">blas_dot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1cp3__tensor.html">cp3_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1enable__if.html">enable_if</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1enable__if_3_01false_00_01_t_01_4.html">enable_if&lt; false, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1except__here.html">except_here</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1exception.html">exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1frustum.html">frustum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1frustum__culler.html">frustum_culler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for OpenGL view frustum culling.  <a href="classvmml_1_1frustum__culler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1intersection.html">intersection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1lapack__svd.html">lapack_svd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1lapack__sym__eigs.html">lapack_sym_eigs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1linear__least__squares.html">linear_least_squares</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1lowpass__filter.html">lowpass_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1matrix.html">matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1set__to__zero__functor.html">set_to_zero_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1set__to__identity__functor.html">set_to_identity_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1matrix__equals__allow__inverted__rows.html">matrix_equals_allow_inverted_rows</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvmml_1_1matrix__equals__allow__inverted__columns.html">matrix_equals_allow_inverted_columns</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1compute__pseudoinverse.html">compute_pseudoinverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1qtucker3__tensor.html">qtucker3_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1quaternion.html">quaternion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__converter.html">t3_converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__hooi.html">t3_hooi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__hopm.html">t3_hopm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__hosvd.html">t3_hosvd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__ihooi.html">t3_ihooi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__ihopm.html">t3_ihopm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t3__ttm.html">t3_ttm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t4__converter.html">t4_converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t4__hooi.html">t4_hooi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t4__hosvd.html">t4_hosvd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1t4__ttm.html">t4_ttm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tensor3.html">tensor3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tensor3__iterator.html">tensor3_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tensor3__const__iterator.html">tensor3_const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tensor4.html">tensor4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tensor__mmapper.html">tensor_mmapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tucker3__exporter.html">tucker3_exporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tucker3__importer.html">tucker3_importer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tucker3__tensor.html">tucker3_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1tucker4__tensor.html">tucker4_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1validator.html">validator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvmml_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a23b24d9e8310db379a30d4e389c82bc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23b24d9e8310db379a30d4e389c82bc0"></a>
typedef <a class="el" href="classvmml_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a><br class="typebreak"/>
&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Aabbf</b></td></tr>
<tr class="separator:a23b24d9e8310db379a30d4e389c82bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e5ca07a4d729e7881fd6e22a7f48c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42e5ca07a4d729e7881fd6e22a7f48c5"></a>
typedef <a class="el" href="classvmml_1_1frustum.html">frustum</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>frustumf</b></td></tr>
<tr class="separator:a42e5ca07a4d729e7881fd6e22a7f48c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcccfea5dc68ee255cb65af1583f9aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbcccfea5dc68ee255cb65af1583f9aa"></a>
typedef <a class="el" href="classvmml_1_1frustum.html">frustum</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>frustumd</b></td></tr>
<tr class="separator:abbcccfea5dc68ee255cb65af1583f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eddc300690544e2980ea7374c2dd26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91eddc300690544e2980ea7374c2dd26"></a>
typedef <a class="el" href="classvmml_1_1frustum__culler.html">frustum_culler</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>frustum_cullerf</b></td></tr>
<tr class="separator:a91eddc300690544e2980ea7374c2dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e34601e26bf3155b9b521ec0477288"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18e34601e26bf3155b9b521ec0477288"></a>
typedef <a class="el" href="classvmml_1_1frustum__culler.html">frustum_culler</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>frustum_cullerd</b></td></tr>
<tr class="separator:a18e34601e26bf3155b9b521ec0477288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f40e3a21e2797f5aa717a5a49c1773"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f40e3a21e2797f5aa717a5a49c1773"></a>
typedef <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mat3f</b></td></tr>
<tr class="separator:ac0f40e3a21e2797f5aa717a5a49c1773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ed8505f30d30482fed359ff7697456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30ed8505f30d30482fed359ff7697456"></a>
typedef <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mat3d</b></td></tr>
<tr class="separator:a30ed8505f30d30482fed359ff7697456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd24615f98f3115179b1dcafc1a51572"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd24615f98f3115179b1dcafc1a51572"></a>
typedef <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mat4f</b></td></tr>
<tr class="separator:afd24615f98f3115179b1dcafc1a51572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f43367067333a6d760872755720f719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f43367067333a6d760872755720f719"></a>
typedef <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mat4d</b></td></tr>
<tr class="separator:a1f43367067333a6d760872755720f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199fa00f54b108aa9461f4c152c0de0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a199fa00f54b108aa9461f4c152c0de0d"></a>
typedef <a class="el" href="classvmml_1_1quaternion.html">quaternion</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>quaternionf</b></td></tr>
<tr class="separator:a199fa00f54b108aa9461f4c152c0de0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1ad86a5597f2528e2279d826df0363"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b1ad86a5597f2528e2279d826df0363"></a>
typedef <a class="el" href="classvmml_1_1quaternion.html">quaternion</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>quaterniond</b></td></tr>
<tr class="separator:a6b1ad86a5597f2528e2279d826df0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7b743e74089ab9c4bcfb621f85d82c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f7b743e74089ab9c4bcfb621f85d82c"></a>
typedef <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 2, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vec2f</b></td></tr>
<tr class="separator:a8f7b743e74089ab9c4bcfb621f85d82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86398d09758f21ce06b47924fb0eecd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa86398d09758f21ce06b47924fb0eecd"></a>
typedef <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 2, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vec2d</b></td></tr>
<tr class="separator:aa86398d09758f21ce06b47924fb0eecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b410fefc218705f5b5c972461dbc4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7b410fefc218705f5b5c972461dbc4f"></a>
typedef <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vec3f</b></td></tr>
<tr class="separator:ad7b410fefc218705f5b5c972461dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75693b360c4f72a7107336f6c23cef4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75693b360c4f72a7107336f6c23cef4e"></a>
typedef <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vec3d</b></td></tr>
<tr class="separator:a75693b360c4f72a7107336f6c23cef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df48414948ca2fdf63aad1c6897a4e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df48414948ca2fdf63aad1c6897a4e6"></a>
typedef <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 4, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vec4f</b></td></tr>
<tr class="separator:a6df48414948ca2fdf63aad1c6897a4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d659faf2fbd728af3396c33fcaa191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94d659faf2fbd728af3396c33fcaa191"></a>
typedef <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 4, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vec4d</b></td></tr>
<tr class="separator:a94d659faf2fbd728af3396c33fcaa191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2462f6dfd257feb022fa79730ec8091c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Visibility</b> { <b>VISIBILITY_NONE</b> = 0, 
<b>VISIBILITY_PARTIAL</b> = 1, 
<b>VISIBILITY_FULL</b> = 2
 }</td></tr>
<tr class="separator:a2462f6dfd257feb022fa79730ec8091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af222867180ecf1632532123cbecf260c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af222867180ecf1632532123cbecf260c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af222867180ecf1632532123cbecf260c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classvmml_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a>&lt; T &gt; &amp;aabb)</td></tr>
<tr class="separator:af222867180ecf1632532123cbecf260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1d0c03f7b2690e9a1173c109e0eb4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1d0c03f7b2690e9a1173c109e0eb4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>error_noexcept</b> (const std::string &amp;desc, const <a class="el" href="structvmml_1_1except__here.html">except_here</a> &amp;here)</td></tr>
<tr class="separator:a6c1d0c03f7b2690e9a1173c109e0eb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c51169899a2d02a4b99701e727511fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c51169899a2d02a4b99701e727511fd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c51169899a2d02a4b99701e727511fd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_jacobi_3x3</b> (<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, T &gt; &amp;a, <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;d, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, T &gt; &amp;v, size_t &amp;rotationCount)</td></tr>
<tr class="separator:a4c51169899a2d02a4b99701e727511fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119be259cda49c01829abe340dd310fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a119be259cda49c01829abe340dd310fc"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a119be259cda49c01829abe340dd310fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;m0, const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;m1, const T tolerance=std::numeric_limits&lt; T &gt;::epsilon())</td></tr>
<tr class="separator:a119be259cda49c01829abe340dd310fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5769cdbac336490caebfc17ffa5b7833"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5769cdbac336490caebfc17ffa5b7833"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a5769cdbac336490caebfc17ffa5b7833"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;left, const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;right, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;result)</td></tr>
<tr class="separator:a5769cdbac336490caebfc17ffa5b7833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8505d02c2f28e4f403e312e77fc182"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e8505d02c2f28e4f403e312e77fc182"></a>
template&lt;size_t M, size_t N, size_t P, typename T &gt; </td></tr>
<tr class="memitem:a4e8505d02c2f28e4f403e312e77fc182"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, P, T &gt; &amp;left, const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; P, N, T &gt; &amp;right, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;result)</td></tr>
<tr class="separator:a4e8505d02c2f28e4f403e312e77fc182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659b6917d2100218bef70c00871befd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a659b6917d2100218bef70c00871befd7"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a659b6917d2100218bef70c00871befd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvmml_1_1enable__if.html">enable_if</a>&lt; M==N &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>identity</b> (<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;m)</td></tr>
<tr class="separator:a659b6917d2100218bef70c00871befd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa83fb22cec85efdedfec64c2fa8dd0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9fa83fb22cec85efdedfec64c2fa8dd0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fa83fb22cec85efdedfec64c2fa8dd0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_determinant</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 1, 1, T &gt; &amp;matrix_)</td></tr>
<tr class="separator:a9fa83fb22cec85efdedfec64c2fa8dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac952d04aed58b875bead1adf0a6e53e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac952d04aed58b875bead1adf0a6e53e6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac952d04aed58b875bead1adf0a6e53e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_determinant</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 2, 2, T &gt; &amp;matrix_)</td></tr>
<tr class="separator:ac952d04aed58b875bead1adf0a6e53e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a579adc5644feeb29a8e11bc7915319"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a579adc5644feeb29a8e11bc7915319"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a579adc5644feeb29a8e11bc7915319"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_determinant</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, T &gt; &amp;m_)</td></tr>
<tr class="separator:a4a579adc5644feeb29a8e11bc7915319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7bdd2140032e91aa65018e2bb216e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade7bdd2140032e91aa65018e2bb216e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade7bdd2140032e91aa65018e2bb216e7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_determinant</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt; &amp;m)</td></tr>
<tr class="separator:ade7bdd2140032e91aa65018e2bb216e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f364a08b729e897f15afd9bc0afbf4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a68f364a08b729e897f15afd9bc0afbf4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68f364a08b729e897f15afd9bc0afbf4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_inverse</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 2, 2, T &gt; &amp;m_, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 2, 2, T &gt; &amp;inverse_, T tolerance_=std::numeric_limits&lt; T &gt;::epsilon())</td></tr>
<tr class="separator:a68f364a08b729e897f15afd9bc0afbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90abd121d75f8b30c46e2a41b195d28c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90abd121d75f8b30c46e2a41b195d28c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90abd121d75f8b30c46e2a41b195d28c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_inverse</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, T &gt; &amp;m_, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 3, 3, T &gt; &amp;inverse_, T tolerance_=std::numeric_limits&lt; T &gt;::epsilon())</td></tr>
<tr class="separator:a90abd121d75f8b30c46e2a41b195d28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7618a940ca903791f23bee923ab65ba4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7618a940ca903791f23bee923ab65ba4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7618a940ca903791f23bee923ab65ba4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_inverse</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt; &amp;m_, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt; &amp;inv_, T tolerance_=std::numeric_limits&lt; T &gt;::epsilon())</td></tr>
<tr class="separator:a7618a940ca903791f23bee923ab65ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17312e971fbac3a1b5b360b7d183317b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17312e971fbac3a1b5b360b7d183317b"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a17312e971fbac3a1b5b360b7d183317b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; N, M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;matrix_)</td></tr>
<tr class="separator:a17312e971fbac3a1b5b360b7d183317b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa276d541c454fa65842f6a5365d54aa7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa276d541c454fa65842f6a5365d54aa7"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:aa276d541c454fa65842f6a5365d54aa7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_positive_definite</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;matrix_, const T limit=-1e12, typename enable_if&lt; M==N &amp;&amp;M&lt;=3 &gt;::type *=0)</td></tr>
<tr class="separator:aa276d541c454fa65842f6a5365d54aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b490229de1854138cc6df651628ae9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0b490229de1854138cc6df651628ae9"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:aa0b490229de1854138cc6df651628ae9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>qr_decompose_gram_schmidt</b> (const <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;A_, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, M, T &gt; &amp;Q, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; N, N, T &gt; &amp;R)</td></tr>
<tr class="separator:aa0b490229de1854138cc6df651628ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41201bdf0af7ac0f64667b2c3feb1ce0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41201bdf0af7ac0f64667b2c3feb1ce0"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a41201bdf0af7ac0f64667b2c3feb1ce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>svdecompose</b> (<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;a, <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; N, T &gt; &amp;w, <a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; N, N, T &gt; &amp;v)</td></tr>
<tr class="separator:a41201bdf0af7ac0f64667b2c3feb1ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd394063881a1c35696bcecfcc91068"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacd394063881a1c35696bcecfcc91068"></a>
VMML_TEMPLATE_STRING bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classvmml_1_1tensor3.html">tensor3</a>&lt; I1, I2, I3, T &gt; &amp;t3_0, const <a class="el" href="classvmml_1_1tensor3.html">tensor3</a>&lt; I1, I2, I3, T &gt; &amp;t3_1, T tolerance)</td></tr>
<tr class="separator:aacd394063881a1c35696bcecfcc91068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d6aa064a768b522937a959237bd3c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d6aa064a768b522937a959237bd3c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>set_lateral_slice_bwd</b> (i,*lateral_slice)</td></tr>
<tr class="separator:a32d6aa064a768b522937a959237bd3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30720a6e5899f71850f235f528f74214"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30720a6e5899f71850f235f528f74214"></a>
other&#160;</td><td class="memItemRight" valign="bottom"><b>get_core</b> (other_core)</td></tr>
<tr class="separator:a30720a6e5899f71850f235f528f74214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c468993ee3e688a840b727f7be423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee8c468993ee3e688a840b727f7be423"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (size_t r3=0;r3&lt; R3;++r3)</td></tr>
<tr class="separator:aee8c468993ee3e688a840b727f7be423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e35f10f1c75a2816d5749d1ca0878c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e35f10f1c75a2816d5749d1ca0878c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cast_comp_members</b> ()</td></tr>
<tr class="separator:a8e35f10f1c75a2816d5749d1ca0878c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09caee5e1e31aee1284e50d5d0454f66"><td class="memTemplParams" colspan="2"><a class="anchor" id="a09caee5e1e31aee1284e50d5d0454f66"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a09caee5e1e31aee1284e50d5d0454f66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equals</b> (T arg0, U arg1)</td></tr>
<tr class="separator:a09caee5e1e31aee1284e50d5d0454f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871107efe3efe922b2bacf141fbdffce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a871107efe3efe922b2bacf141fbdffce"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a871107efe3efe922b2bacf141fbdffce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_translation</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M-1, T &gt; &amp;arg)</td></tr>
<tr class="separator:a871107efe3efe922b2bacf141fbdffce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a5132bc04802c00d19b4a8da4c178"><td class="memTemplParams" colspan="2"><a class="anchor" id="a896a5132bc04802c00d19b4a8da4c178"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a896a5132bc04802c00d19b4a8da4c178"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_translation</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;arg)</td></tr>
<tr class="separator:a896a5132bc04802c00d19b4a8da4c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae342962c8f351f3ff353da5a09dafcf2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae342962c8f351f3ff353da5a09dafcf2"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:ae342962c8f351f3ff353da5a09dafcf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_translation</b> (<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;m, T t0, T t1, T t2)</td></tr>
<tr class="separator:ae342962c8f351f3ff353da5a09dafcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f0fcd65fa2ce2d7f7d65b7baba6669"><td class="memTemplParams" colspan="2"><a class="anchor" id="a07f0fcd65fa2ce2d7f7d65b7baba6669"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:a07f0fcd65fa2ce2d7f7d65b7baba6669"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_rotation</b> (T angle, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M-1, T &gt; &amp;axis)</td></tr>
<tr class="separator:a07f0fcd65fa2ce2d7f7d65b7baba6669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5bfd27c3fcbda3b5f7d60e088a9494"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e5bfd27c3fcbda3b5f7d60e088a9494"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e5bfd27c3fcbda3b5f7d60e088a9494"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_rotation</b> (T angle, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;axis)</td></tr>
<tr class="separator:a6e5bfd27c3fcbda3b5f7d60e088a9494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceccf18c418275bb894e30f8c5b26a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="afceccf18c418275bb894e30f8c5b26a1"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:afceccf18c418275bb894e30f8c5b26a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_rotation</b> (<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt; &amp;m, T angle, T t0, T t1, T t2)</td></tr>
<tr class="separator:afceccf18c418275bb894e30f8c5b26a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e3cb5aa6e4be335c421ba141bea949"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7e3cb5aa6e4be335c421ba141bea949"></a>
template&lt;size_t M, size_t N, typename T &gt; </td></tr>
<tr class="memitem:aa7e3cb5aa6e4be335c421ba141bea949"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_scaling</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; N-1, T &gt; &amp;arg)</td></tr>
<tr class="separator:aa7e3cb5aa6e4be335c421ba141bea949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6ff4e4be1e18a35658fc6156e3866"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8be6ff4e4be1e18a35658fc6156e3866"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8be6ff4e4be1e18a35658fc6156e3866"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_scaling</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;arg)</td></tr>
<tr class="separator:a8be6ff4e4be1e18a35658fc6156e3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e42c4a53da480d35d581b38ac0e491"><td class="memTemplParams" colspan="2"><a class="anchor" id="a51e42c4a53da480d35d581b38ac0e491"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51e42c4a53da480d35d581b38ac0e491"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; 4, 4, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_scaling</b> (T arg)</td></tr>
<tr class="separator:a51e42c4a53da480d35d581b38ac0e491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d196bd81e390392c88e799a0e64df4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a36d196bd81e390392c88e799a0e64df4"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:a36d196bd81e390392c88e799a0e64df4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zero</b> (<a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;arg)</td></tr>
<tr class="separator:a36d196bd81e390392c88e799a0e64df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70783bc27da19f7040c77a1ff0a3cb2"><td class="memTemplParams" colspan="2"><a class="anchor" id="af70783bc27da19f7040c77a1ff0a3cb2"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:af70783bc27da19f7040c77a1ff0a3cb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;arg0, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;arg1)</td></tr>
<tr class="separator:af70783bc27da19f7040c77a1ff0a3cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4316f22a616b554a25c8a904a7d3eb2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4316f22a616b554a25c8a904a7d3eb2"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:ab4316f22a616b554a25c8a904a7d3eb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;arg0, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;arg1)</td></tr>
<tr class="separator:ab4316f22a616b554a25c8a904a7d3eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be7e813fec46488bdedc79881deb8b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9be7e813fec46488bdedc79881deb8b8"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:a9be7e813fec46488bdedc79881deb8b8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>manhattan</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;arg)</td></tr>
<tr class="separator:a9be7e813fec46488bdedc79881deb8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7014d1e924c3883766e798b76379ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c7014d1e924c3883766e798b76379ed"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:a4c7014d1e924c3883766e798b76379ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equals</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;a, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;b)</td></tr>
<tr class="separator:a4c7014d1e924c3883766e798b76379ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1508558ced277f6e758d04113df5566"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1508558ced277f6e758d04113df5566"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:ac1508558ced277f6e758d04113df5566"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;first, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;second)</td></tr>
<tr class="separator:ac1508558ced277f6e758d04113df5566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248842049d4a84c2a22cad95477c949f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a248842049d4a84c2a22cad95477c949f"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:a248842049d4a84c2a22cad95477c949f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;a, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;b)</td></tr>
<tr class="separator:a248842049d4a84c2a22cad95477c949f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240c91f7fbc16dc2a9d9116ce05b7209"><td class="memTemplParams" colspan="2"><a class="anchor" id="a240c91f7fbc16dc2a9d9116ce05b7209"></a>
template&lt;size_t M, typename T &gt; </td></tr>
<tr class="memitem:a240c91f7fbc16dc2a9d9116ce05b7209"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>normalize</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; M, T &gt; &amp;vector_)</td></tr>
<tr class="separator:a240c91f7fbc16dc2a9d9116ce05b7209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101f0a8d731640c204c5ac9a0637ee40"><td class="memTemplParams" colspan="2"><a class="anchor" id="a101f0a8d731640c204c5ac9a0637ee40"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a101f0a8d731640c204c5ac9a0637ee40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 4, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_plane</b> (const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;a, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;b, const <a class="el" href="classvmml_1_1vector.html">vector</a>&lt; 3, T &gt; &amp;c)</td></tr>
<tr class="separator:a101f0a8d731640c204c5ac9a0637ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939f687b21f07720c52e10208c004161"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a939f687b21f07720c52e10208c004161"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const Visibility &amp;v)</td></tr>
<tr class="separator:a939f687b21f07720c52e10208c004161"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3ab774a6e1bc9a395bc52303a1f9cd7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ab774a6e1bc9a395bc52303a1f9cd7d"></a>
template&lt;size_t O, size_t P&gt; </td></tr>
<tr class="memitem:a3ab774a6e1bc9a395bc52303a1f9cd7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvmml_1_1enable__if.html">enable_if</a>&lt; O&lt;=M &amp;&amp;P&lt;=N &gt;::type <br class="typebreak"/>
*<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;<br class="typebreak"/>
::get_sub_matrix(<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; O, P, <br class="typebreak"/>
T &gt; &amp;result, size_t row_offset, <br class="typebreak"/>
size_t col_offset) const {for(size_t <br class="typebreak"/>
row=0;row&lt; O;++row){for(size_t <br class="typebreak"/>
col=0;col&lt; P;++col){result.at(row, <br class="typebreak"/>
col)=at(row_offset+row, <br class="typebreak"/>
col_offset+col);}}return <br class="typebreak"/>
0;}template&lt; size_t M, size_t <br class="typebreak"/>
N, typename T &gt;template<br class="typebreak"/>
&lt; size_t O, size_t P &gt;typename <br class="typebreak"/>
<a class="el" href="structvmml_1_1enable__if.html">enable_if</a>&lt; O&lt;=M &amp;&amp;P&lt;=N &gt;::type <br class="typebreak"/>
*<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;<br class="typebreak"/>
::set_sub_matrix(const <a class="el" href="classvmml_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; O, P, T &gt; &amp;sub_matrix, <br class="typebreak"/>
size_t row_offset, size_t <br class="typebreak"/>
col_offset){for(size_t row=0;row<br class="typebreak"/>
&lt; O;++row){for(size_t col=0;col<br class="typebreak"/>
&lt; P;++col){at(row_offset+row, <br class="typebreak"/>
col_offset+col)=sub_matrix.at(row, <br class="typebreak"/>
col);}}return 0;}template<br class="typebreak"/>
&lt; size_t M, size_t N, typename <br class="typebreak"/>
T &gt;inline Tmatrix&lt; M, N, T &gt;<br class="typebreak"/>
::det() const {return <br class="typebreak"/>
compute_determinant(*this);}template<br class="typebreak"/>
&lt; size_t M, size_t N, typename <br class="typebreak"/>
T &gt;template&lt; size_t O, size_t <br class="typebreak"/>
P, typename TT &gt;inline bool <br class="typebreak"/>
<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;::inverse(<a class="el" href="classvmml_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; O, P, TT &gt; &amp;inverse_, T <br class="typebreak"/>
tolerance, typename <a class="el" href="structvmml_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; M==N &amp;&amp;O==P &amp;&amp;O==M &amp;&amp;M &gt;<br class="typebreak"/>
=2 &amp;&amp;M&lt;=4, TT &gt;::type *) const <br class="typebreak"/>
{return compute_inverse(*this, <br class="typebreak"/>
inverse_, tolerance);}template<br class="typebreak"/>
&lt; size_t M, size_t N, typename <br class="typebreak"/>
T &gt;template&lt; size_t O, size_t <br class="typebreak"/>
P &gt;typename <a class="el" href="structvmml_1_1enable__if.html">enable_if</a>&lt; O==P <br class="typebreak"/>
&amp;&amp;M==N &amp;&amp;O==M &amp;&amp;M &gt;=2 &gt;::type <br class="typebreak"/>
*<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, T &gt;<br class="typebreak"/>
::get_adjugate(<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; O, P, T &gt;<br class="typebreak"/>
 &amp;adjugate) const <br class="typebreak"/>
{get_cofactors(adjugate);adjugate=transpose(adjugate);return <br class="typebreak"/>
0;}template&lt; size_t M, size_t <br class="typebreak"/>
N, typename T &gt;template<br class="typebreak"/>
&lt; size_t O, size_t P &gt;typename <br class="typebreak"/>
<a class="el" href="structvmml_1_1enable__if.html">enable_if</a>&lt; O==P &amp;&amp;M==N &amp;&amp;O==M <br class="typebreak"/>
&amp;&amp;M &gt;=2 &gt;::type *<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M, N, <br class="typebreak"/>
T &gt;::get_cofactors(<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; O, <br class="typebreak"/>
P, T &gt; &amp;cofactors) const <br class="typebreak"/>
{<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; M-1, N-1, T &gt; minor_;const <br class="typebreak"/>
size_t _negate=1u;for(size_t row_index=0;row_index&lt; M;++row_index){for(size_t col_index=0;col_index&lt; N;++col_index){if((row_index+col_index)&amp;_negate) cofactors(row_index, col_index)=-get_minor(minor_, row_index, col_index);else cofactors(row_index, col_index)=get_minor(minor_, row_index, col_index);}}return 0;}template&lt; size_t M, size_t N, typename T &gt;template&lt; size_t O, size_t P &gt;Tmatrix&lt; M, N, T &gt;::get_minor(matrix&lt; O, P, T &gt; &amp;minor_, size_t row_to_cut, size_t col_to_cut, typename enable_if&lt; O==M-1 &amp;&amp;P==N-1 &amp;&amp;M==N &amp;&amp;M &gt;=2 &gt;::type *) const {size_t row_offset=0;size_t col_offset=0;for(size_t row_index=0;row_index&lt; M;++row_index){if(row_index==row_to_cut) row_offset=-1;else{for(size_t col_index=0;col_index&lt; M;++col_index){if(col_index==col_to_cut) col_offset=-1;else minor_.at(row_index+row_offset, col_index+col_offset)=at(row_index, col_index);}col_offset=0;}}return compute_determinant(minor_);}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::rotate(const TT angle_, const vector&lt; M-1, T &gt; &amp;axis, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);const T _zero=0.0;const T one=1.0;const T two=2.0;array[0]=cosine+(one-cosine)*std::pow(axis.array[0], two);array[1]=(one-cosine)*axis.array[0]*axis.array[1]+sine *axis.array[2];array[2]=(one-cosine)*axis.array[0]*axis.array[2]-sine *axis.array[1];array[3]=_zero;array[4]=(one-cosine)*axis.array[0]*axis.array[1]-sine *axis.array[2];array[5]=cosine+(one-cosine)*std::pow(axis.array[1], two);array[6]=(one-cosine)*axis.array[1]*axis.array[2]+sine *axis.array[0];array[7]=_zero;array[8]=(one-cosine)*axis.array[0]*axis.array[2]+sine *axis.array[1];array[9]=(one-cosine)*axis.array[1]*axis.array[2]-sine *axis.array[0];array[10]=cosine+(one-cosine)*std::pow(axis.array[2], two);array[11]=_zero;array[12]=_zero;array[13]=_zero;array[14]=_zero;array[15]=one;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::rotate_x(const TT angle_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);T tmp;tmp=array[4]*cosine+array[8]*sine;array[8]=-array[4]*sine+array[8]*cosine;array[4]=tmp;tmp=array[5]*cosine+array[9]*sine;array[9]=-array[5]*sine+array[9]*cosine;array[5]=tmp;tmp=array[6]*cosine+array[10]*sine;array[10]=-array[6]*sine+array[10]*cosine;array[6]=tmp;tmp=array[7]*cosine+array[11]*sine;array[11]=-array[7]*sine+array[11]*cosine;array[7]=tmp;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::rotate_y(const TT angle_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);T tmp;tmp=array[0]*cosine-array[8]*sine;array[8]=array[0]*sine+array[8]*cosine;array[0]=tmp;tmp=array[1]*cosine-array[9]*sine;array[9]=array[1]*sine+array[9]*cosine;array[1]=tmp;tmp=array[2]*cosine-array[10]*sine;array[10]=array[2]*sine+array[10]*cosine;array[2]=tmp;tmp=array[3]*cosine-array[11]*sine;array[11]=array[3]*sine+array[11]*cosine;array[3]=tmp;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::rotate_z(const TT angle_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);T tmp;tmp=array[0]*cosine+array[4]*sine;array[4]=-array[0]*sine+array[4]*cosine;array[0]=tmp;tmp=array[1]*cosine+array[5]*sine;array[5]=-array[1]*sine+array[5]*cosine;array[1]=tmp;tmp=array[2]*cosine+array[6]*sine;array[6]=-array[2]*sine+array[6]*cosine;array[2]=tmp;tmp=array[3]*cosine+array[7]*sine;array[7]=-array[3]*sine+array[7]*cosine;array[3]=tmp;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::pre_rotate_x(const TT angle_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);T tmp;tmp=array[1];array[1]=array[1]*cosine+array[2]*sine;array[2]=tmp *-sine+array[2]*cosine;tmp=array[5];array[5]=array[5]*cosine+array[6]*sine;array[6]=tmp *-sine+array[6]*cosine;tmp=array[9];array[9]=array[9]*cosine+array[10]*sine;array[10]=tmp *-sine+array[10]*cosine;tmp=array[13];array[13]=array[13]*cosine+array[14]*sine;array[14]=tmp *-sine+array[14]*cosine;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::pre_rotate_y(const TT angle_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);T tmp;tmp=array[0];array[0]=array[0]*cosine-array[2]*sine;array[2]=tmp *sine+array[2]*cosine;tmp=array[4];array[4]=array[4]*cosine-array[6]*sine;array[6]=tmp *sine+array[6]*cosine;tmp=array[8];array[8]=array[8]*cosine-array[10]*sine;array[10]=tmp *sine+array[10]*cosine;tmp=array[12];array[12]=array[12]*cosine-array[14]*sine;array[14]=tmp *sine+array[14]*cosine;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::pre_rotate_z(const TT angle_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T angle=static_cast&lt; T &gt; angle_);const T sine=std::sin(angle);const T cosine=std::cos(angle);T tmp;tmp=array[0];array[0]=array[0]*cosine+array[1]*sine;array[1]=tmp *-sine+array[1]*cosine;tmp=array[4];array[4]=array[4]*cosine+array[5]*sine;array[5]=tmp *-sine+array[5]*cosine;tmp=array[8];array[8]=array[8]*cosine+array[9]*sine;array[9]=tmp *-sine+array[9]*cosine;tmp=array[12];array[12]=array[12]*cosine+array[13]*sine;array[13]=tmp *-sine+array[13]*cosine;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::scale(const TT _scale[3], typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T scale0=static_cast&lt; T &gt; _scale[0]);const T scale1=static_cast&lt; T &gt; _scale[1]);const T scale2=static_cast&lt; T &gt; _scale[2]);array[0]*=scale0;array[1]*=scale0;array[2]*=scale0;array[3]*=scale0;array[4]*=scale1;array[5]*=scale1;array[6]*=scale1;array[7]*=scale1;array[8]*=scale2;array[9]*=scale2;array[10]*=scale2;array[11]*=scale2;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::scale(const TT x_, const T y_, const T z_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){const T _x=static_cast&lt; T &gt; x_);array[0]*=_x;array[1]*=_x;array[2]*=_x;array[3]*=_x;array[4]*=y_;array[5]*=y_;array[6]*=y_;array[7]*=y_;array[8]*=z_;array[9]*=z_;array[10]*=z_;array[11]*=z_;return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;inline matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::scale(const vector&lt; 3, TT &gt; &amp;scale_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){return scale(scale_.array);}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::scale_translation(const TT scale_[3], typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){array[12]*=static_cast&lt; T &gt; scale_[0]);array[13]*=static_cast&lt; T &gt; scale_[1]);array[14]*=static_cast&lt; T &gt; scale_[2]);return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;inline matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::scale_translation(const vector&lt; 3, TT &gt; &amp;scale_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){return scale_translation(scale_.array);}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;inline matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::set_translation(const TT x_, const TT y_, const TT z_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){array[12]=static_cast&lt; T &gt; x_);array[13]=static_cast&lt; T &gt; y_);array[14]=static_cast&lt; T &gt; z_);return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;inline matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::set_translation(const TT trans[3], typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){array[12]=static_cast&lt; T &gt; trans[0]);array[13]=static_cast&lt; T &gt; trans[1]);array[14]=static_cast&lt; T &gt; trans[2]);return *this;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;inline matrix&lt; M, N, T &gt; &amp;matrix&lt; M, N, T &gt;::set_translation(const vector&lt; 3, TT &gt; &amp;translation_, typename enable_if&lt; M==N &amp;&amp;M==4, TT &gt;::type *){return set_translation(translation_.array);}template&lt; size_t M, size_t N, typename T &gt; template&lt; typename TT &gt; inlinevoid matrix&lt; M, N, T &gt;::get_translation(vector&lt; N-1, TT &gt; &amp;translation_) const {for(size_t i=0;i&lt; N-1;++i) translation_.array[i]=array[i+M *(N-1)];}template&lt; size_t M, size_t N, typename T &gt;inline vector&lt; N-1, T &gt; matrix&lt; M, N, T &gt;::get_translation() const {vector&lt; N-1, T &gt; result;get_translation(result);return result;}template&lt; size_t M, size_t N, typename T &gt;size_tmatrix&lt; M, N, T &gt;::size() const {return M *N;}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::iteratormatrix&lt; M, N, T &gt;::begin(){return array;}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::iteratormatrix&lt; M, N, T &gt;::end(){return array+size();}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::const_iteratormatrix&lt; M, N, T &gt;::begin() const {return array;}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::const_iteratormatrix&lt; M, N, T &gt;::end() const {return array+size();}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::reverse_iteratormatrix&lt; M, N, T &gt;::rbegin(){return array+size()-1;}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::reverse_iteratormatrix&lt; M, N, T &gt;::rend(){return array-1;}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::const_reverse_iteratormatrix&lt; M, N, T &gt;::rbegin() const {return array+size()-1;}template&lt; size_t M, size_t N, typename T &gt;typename matrix&lt; M, N, T &gt;::const_reverse_iteratormatrix&lt; M, N, T &gt;::rend() const {return array-1;}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename init_functor_t &gt;const matrix&lt; M, N, T &gt;matrix&lt; M, N, T &gt;::get_initialized_matrix(){matrix&lt; M, N, T &gt; matrix_;init_functor_t()(matrix_);return matrix_;}template&lt; size_t M, size_t N, typename T &gt;const matrix&lt; M, N, T &gt;matrix&lt; M, N, T &gt;::IDENTITY(matrix&lt; M, N, T &gt;::get_initialized_matrix&lt; set_to_identity_functor&lt; matrix&lt; M, N, T &gt; &gt; &gt;));template&lt; size_t M, size_t N, typename T &gt;const matrix&lt; M, N, T &gt;matrix&lt; M, N, T &gt;::ZERO(matrix&lt; M, N, T &gt;::get_initialized_matrix&lt; set_to_zero_functor&lt; matrix&lt; M, N, T &gt; &gt; &gt;));template&lt; size_t M, size_t N, typename T &gt;doublematrix&lt; M, N, T &gt;::frobenius_norm() const {double norm=0.0;const_iterator it=begin(), it_end=end();for(;it!=it_end;++it){norm+=*it **it;}return std::sqrt(norm);}template&lt; size_t M, size_t N, typename T &gt;doublematrix&lt; M, N, T &gt;::p_norm(double p) const {double norm=0.0;const_iterator it=begin(), it_end=end();for(;it!=it_end;++it){norm+=std::pow(*it, p);}return std::pow(norm, 1./p);}template&lt; size_t M, size_t N, typename T &gt;template&lt; size_t O &gt;voidmatrix&lt; M, N, T &gt;::khatri_rao_product(const matrix&lt; O, N, T &gt; &amp;right_, matrix&lt; M *O, N, T &gt; &amp;prod_) const {for(size_t col=0;col&lt; N;++col){for(size_t m=0;m&lt; M;++m){for(size_t o=0;o&lt; O;++o){prod_.at(O *m+o, col)=at(m, col)*right_.at(o, col);}}}}template&lt; size_t M, size_t N, typename T &gt;template&lt; size_t O, size_t P &gt;voidmatrix&lt; M, N, T &gt;::kronecker_product(const matrix&lt; O, P, T &gt; &amp;right_, matrix&lt; M *O, N *P, T &gt; &amp;result_) const {for(size_t m=0;m&lt; M;++m){for(size_t n=0;n&lt; N;++n){for(size_t o=0;o&lt; O;++o){for(size_t p=0;p&lt; P;++p){result_.at(O *m+o, P *n+p)=at(m, n)*right_.at(o, p);}}}}}template&lt; size_t M, size_t N, typename T &gt;template&lt; typename TT &gt;voidmatrix&lt; M, N, T &gt;::cast_from(const matrix&lt; M, N, TT &gt; &amp;other){typedef vmml::matrix&lt; M, N, TT &gt; matrix_tt_type;typedef typename matrix_tt_type::const_iterator tt_const_iterator;iterator it=begin(), it_end=end();tt_const_iterator other_it=other.begin();for(;it!=it_end;++it,++other_it){*it=static_cast&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>other_it</b></td></tr>
<tr class="separator:a3ab774a6e1bc9a395bc52303a1f9cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ce4ab7b48e946d48bfbd27960fd5f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a72ce4ab7b48e946d48bfbd27960fd5f4"></a>
template&lt;size_t J1, size_t J2, size_t J3&gt; </td></tr>
<tr class="memitem:a72ce4ab7b48e946d48bfbd27960fd5f4"><td class="memTemplItemLeft" align="right" valign="top">VMML_TEMPLATE_STRING <a class="el" href="structvmml_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; J1&lt;=I1 &amp;&amp;J2&lt;=I2 &amp;&amp;J3&lt;=I3 &gt;<br class="typebreak"/>
::type <br class="typebreak"/>
*VMML_TEMPLATE_CLASSNAME::set_sub_core(const <br class="typebreak"/>
<a class="el" href="classvmml_1_1tensor3.html">tensor3</a>&lt; J1, J2, J3, T_coeff &gt;<br class="typebreak"/>
 &amp;sub_data_, size_t row_offset, <br class="typebreak"/>
size_t col_offset, size_t <br class="typebreak"/>
slice_offset){_core_comp.set_sub_tensor3(sub_data_, <br class="typebreak"/>
row_offset, col_offset, <br class="typebreak"/>
slice_offset);_core.cast_from(_core_comp);}VMML_TEMPLATE_STRING <br class="typebreak"/>
void <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::als_rand(const <br class="typebreak"/>
t3_type &amp;data_){typedef <br class="typebreak"/>
<a class="el" href="classvmml_1_1t3__hooi.html">t3_hooi</a>&lt; R1, R2, R3, I1, I2, <br class="typebreak"/>
I3, T_internal &gt; hooi_type;tucker_als(data_, <br class="typebreak"/>
typename <br class="typebreak"/>
hooi_type::init_random());}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; typename T_init &gt;<br class="typebreak"/>
 <a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::decompose(const <br class="typebreak"/>
t3_type &amp;data_, T_init init, <br class="typebreak"/>
const size_t max_iterations, <br class="typebreak"/>
const float tolerance){return <br class="typebreak"/>
tucker_als(data_, init, <br class="typebreak"/>
max_iterations, tolerance);}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; typename T_init &gt;<br class="typebreak"/>
 <a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::tucker_als(const <br class="typebreak"/>
t3_type &amp;data_, T_init init, <br class="typebreak"/>
const size_t max_iterations, <br class="typebreak"/>
const float tolerance){<a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
result;t3_comp_type data;data.cast_from(data_);typedef <br class="typebreak"/>
<a class="el" href="classvmml_1_1t3__hooi.html">t3_hooi</a>&lt; R1, R2, R3, I1, I2, <br class="typebreak"/>
I3, T_internal &gt; hooi_type;result+=hooi_type::als(data,*_u1_comp,*_u2_comp,*_u3_comp, <br class="typebreak"/>
_core_comp, init, <br class="typebreak"/>
0, max_iterations, tolerance);cast_members();return <br class="typebreak"/>
result;}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; size_t NBLOCKS, <br class="typebreak"/>
typename T_init &gt; <a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::i_tucker_als(const <br class="typebreak"/>
t3_type &amp;data_, T_init init, <br class="typebreak"/>
const size_t max_iterations, <br class="typebreak"/>
const float tolerance){<a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
result;t3_comp_type data;data.cast_from(data_);typedef <br class="typebreak"/>
<a class="el" href="classvmml_1_1t3__ihooi.html">t3_ihooi</a>&lt; R1, R2, R3, NBLOCKS, <br class="typebreak"/>
I1, I2, I3, T_internal &gt;<br class="typebreak"/>
 ihooi_type;result+=ihooi_type::i_als(data,*_u1_comp,*_u2_comp,*_u3_comp, <br class="typebreak"/>
_core_comp, init, <br class="typebreak"/>
0, max_iterations, tolerance);cast_members();return <br class="typebreak"/>
result;}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; size_t R, size_t <br class="typebreak"/>
NBLOCKS, typename T_init &gt;<br class="typebreak"/>
 <a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::i_cp_tucker_als(const <br class="typebreak"/>
t3_type &amp;data_, T_init init, <br class="typebreak"/>
const size_t max_iterations, <br class="typebreak"/>
const float tolerance){<a class="el" href="classvmml_1_1tensor__stats.html">tensor_stats</a> <br class="typebreak"/>
result;t3_comp_type data;data.cast_from(data_);typedef <br class="typebreak"/>
<a class="el" href="classvmml_1_1t3__ihooi.html">t3_ihooi</a>&lt; R1, R2, R3, NBLOCKS, <br class="typebreak"/>
I1, I2, I3, T_internal &gt;<br class="typebreak"/>
 ihooi_type;result+=ihooi_type::template <br class="typebreak"/>
i_cp_als&lt; R &gt;data,*_u1_comp,*_u2_comp,*_u3_comp, <br class="typebreak"/>
_core_comp, init, <br class="typebreak"/>
0, max_iterations, tolerance);cast_members();return <br class="typebreak"/>
result;}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; size_t K1, size_t K2, <br class="typebreak"/>
size_t K3 &gt; void <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::reduce_ranks(const <br class="typebreak"/>
<a class="el" href="classvmml_1_1tucker3__tensor.html">tucker3_tensor</a>&lt; K1, K2, K3, I1, <br class="typebreak"/>
I2, I3, T_value, T_coeff &gt;<br class="typebreak"/>
 &amp;other){assert(R1&lt;=K1);assert(R2<br class="typebreak"/>
&lt;=K2);assert(R3&lt;=K3);<a class="el" href="classvmml_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; I1, K1, T_coeff &gt; *u1=new <br class="typebreak"/>
<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; I1, K1, T_coeff &gt;<br class="typebreak"/>
);other.get_u1(*u1);for(size_t <br class="typebreak"/>
r1=0;r1&lt; R1;++r1){_u1-&gt;<br class="typebreak"/>
set_column(r1, u1-&gt;get_column(r1));}<a class="el" href="classvmml_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; I2, K2, T_coeff &gt; *u2=new <br class="typebreak"/>
<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; I2, K2, T_coeff &gt;<br class="typebreak"/>
);other.get_u2(*u2);for(size_t <br class="typebreak"/>
r2=0;r2&lt; R2;++r2){_u2-&gt;<br class="typebreak"/>
set_column(r2, u2-&gt;get_column(r2));}<a class="el" href="classvmml_1_1matrix.html">matrix</a><br class="typebreak"/>
&lt; I3, K3, T_coeff &gt; *u3=new <br class="typebreak"/>
<a class="el" href="classvmml_1_1matrix.html">matrix</a>&lt; I3, K3, T_coeff &gt;<br class="typebreak"/>
);other.get_u3(*u3);for(size_t <br class="typebreak"/>
r3=0;r3&lt; R3;++r3){_u3-&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_column</b> (r3, u3-&gt;get_column(r3))</td></tr>
<tr class="separator:a72ce4ab7b48e946d48bfbd27960fd5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150045ff1e1c8ebe5f4e2f5fe50f3869"><td class="memTemplParams" colspan="2"><a class="anchor" id="a150045ff1e1c8ebe5f4e2f5fe50f3869"></a>
template&lt;size_t J1, size_t J2, size_t J3&gt; </td></tr>
<tr class="memitem:a150045ff1e1c8ebe5f4e2f5fe50f3869"><td class="memTemplItemLeft" align="right" valign="top">VMML_TEMPLATE_STRING <a class="el" href="structvmml_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; J1&lt;=I1 &amp;&amp;J2&lt;=I2 &amp;&amp;J3&lt;=I3 &gt;<br class="typebreak"/>
::type <br class="typebreak"/>
*VMML_TEMPLATE_CLASSNAME::get_sub_tensor3(<a class="el" href="classvmml_1_1tensor3.html">tensor3</a><br class="typebreak"/>
&lt; J1, J2, J3, T &gt; &amp;result, <br class="typebreak"/>
size_t row_offset, size_t <br class="typebreak"/>
col_offset, size_t <br class="typebreak"/>
slice_offset) const {for(size_t <br class="typebreak"/>
slice=0;slice&lt; J3;++slice){for(size_t <br class="typebreak"/>
row=0;row&lt; J1;++row){for(size_t <br class="typebreak"/>
col=0;col&lt; J2;++col){result.at(row, <br class="typebreak"/>
col, slice)=at(row_offset+row, <br class="typebreak"/>
col_offset+col, slice_offset+slice);}}}return <br class="typebreak"/>
0;}VMML_TEMPLATE_STRING void <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::get_sub_tensor3(char <br class="typebreak"/>
*data_, const size_t i1_start, <br class="typebreak"/>
const size_t i1_end, const <br class="typebreak"/>
size_t i2_start, const size_t <br class="typebreak"/>
i2_end, const size_t i3_start, <br class="typebreak"/>
const size_t i3_end) const {T <br class="typebreak"/>
*t_ptr=(T *)&amp;(data_[0]);for(size_t <br class="typebreak"/>
slice=i3_start;slice&lt;=i3_end;++slice){for(size_t <br class="typebreak"/>
col=i2_start;col&lt;=i2_end;++col){for(size_t <br class="typebreak"/>
row=i1_start;row&lt;=i1_end;++row){*t_ptr=at(row, <br class="typebreak"/>
col, slice);++t_ptr;}}}}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; size_t J1, size_t J2, <br class="typebreak"/>
size_t J3 &gt; typename <a class="el" href="structvmml_1_1enable__if.html">enable_if</a><br class="typebreak"/>
&lt; J1&lt;=I1 &amp;&amp;J2&lt;=I2 &amp;&amp;J3&lt;=I3 &gt;<br class="typebreak"/>
::type <br class="typebreak"/>
*VMML_TEMPLATE_CLASSNAME::set_sub_tensor3(const <br class="typebreak"/>
<a class="el" href="classvmml_1_1tensor3.html">tensor3</a>&lt; J1, J2, J3, T &gt;<br class="typebreak"/>
 &amp;sub_data_, size_t row_offset, <br class="typebreak"/>
size_t col_offset, size_t <br class="typebreak"/>
slice_offset){for(size_t slice=0;slice<br class="typebreak"/>
&lt; J3;++slice){for(size_t row=0;row<br class="typebreak"/>
&lt; J1;++row){for(size_t col=0;col<br class="typebreak"/>
&lt; J2;++col){at(row_offset+row, <br class="typebreak"/>
col_offset+col, slice_offset+slice)=sub_data_.at(row, <br class="typebreak"/>
col, slice);}}}return <br class="typebreak"/>
0;}VMML_TEMPLATE_STRING void <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::set_sub_tensor3(const <br class="typebreak"/>
char *data_, const size_t <br class="typebreak"/>
i1_start, const size_t i1_end, <br class="typebreak"/>
const size_t i2_start, const <br class="typebreak"/>
size_t i2_end, const size_t <br class="typebreak"/>
i3_start, const size_t i3_end){T <br class="typebreak"/>
*t_ptr=(T *)&amp;(data_[0]);for(size_t <br class="typebreak"/>
slice=i3_start;slice&lt;=i3_end;++slice){for(size_t <br class="typebreak"/>
col=i2_start;col&lt;=i2_end;++col){for(size_t <br class="typebreak"/>
row=i1_start;row&lt;=i1_end;++row){at(row, <br class="typebreak"/>
col, slice)=*t_ptr;++t_ptr;}}}}VMML_TEMPLATE_STRING <br class="typebreak"/>
typename <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::iterator <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::begin(){return <br class="typebreak"/>
iterator(*this, true);}VMML_TEMPLATE_STRING <br class="typebreak"/>
typename <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::iterator <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::end(){return <br class="typebreak"/>
iterator(*this, false);}VMML_TEMPLATE_STRING <br class="typebreak"/>
typename <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::const_iterator <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::begin() <br class="typebreak"/>
const {return const_iterator(*this, <br class="typebreak"/>
true);}VMML_TEMPLATE_STRING <br class="typebreak"/>
typename <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::const_iterator <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::end() <br class="typebreak"/>
const {return const_iterator(*this, <br class="typebreak"/>
false);}VMML_TEMPLATE_STRING <br class="typebreak"/>
template&lt; typename <br class="typebreak"/>
input_iterator_t &gt; void <br class="typebreak"/>
VMML_TEMPLATE_CLASSNAME::set(input_iterator_t <br class="typebreak"/>
begin_, input_iterator_t end_, <br class="typebreak"/>
bool row_major_layout){input_iterator_t <br class="typebreak"/>
it(begin_);if(row_major_layout){for(size_t <br class="typebreak"/>
i3=0;i3&lt; I3;++i3){for(size_t <br class="typebreak"/>
i1=0;i1&lt; I1;++i1){for(size_t <br class="typebreak"/>
i2=0;i2&lt; I2;++i2,++it){if(it==end_) <br class="typebreak"/>
return;at(i1, i2, i3)=static_cast<br class="typebreak"/>
&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>it</b></td></tr>
<tr class="separator:a150045ff1e1c8ebe5f4e2f5fe50f3869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419af94c70b72de8d66d63c647e6f905"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419af94c70b72de8d66d63c647e6f905"></a>
delete&#160;</td><td class="memItemRight" valign="bottom"><b>lateral_slice</b></td></tr>
<tr class="separator:a419af94c70b72de8d66d63c647e6f905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f348b4b4ea27b94f7c0a69c8a2fd27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>else</b></td></tr>
<tr class="separator:a05f348b4b4ea27b94f7c0a69c8a2fd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8127f1d2cd9ab1adbe3b9385b825a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c8127f1d2cd9ab1adbe3b9385b825a9"></a>
<a class="el" href="classvmml_1_1tensor3.html">tensor3</a>&lt; K1, K2, K3, T_coeff &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>other_core</b></td></tr>
<tr class="separator:a2c8127f1d2cd9ab1adbe3b9385b825a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319b1d6af8b9bc09826471f736713769"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a319b1d6af8b9bc09826471f736713769"></a>
delete&#160;</td><td class="memItemRight" valign="bottom"><b>u1</b></td></tr>
<tr class="separator:a319b1d6af8b9bc09826471f736713769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c658e81060251021faa28038c44c58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c658e81060251021faa28038c44c58"></a>
delete&#160;</td><td class="memItemRight" valign="bottom"><b>u2</b></td></tr>
<tr class="separator:a72c658e81060251021faa28038c44c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c69c3d2c5a5d5fd008d099e3964b04d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c69c3d2c5a5d5fd008d099e3964b04d"></a>
delete&#160;</td><td class="memItemRight" valign="bottom"><b>u3</b></td></tr>
<tr class="separator:a9c69c3d2c5a5d5fd008d099e3964b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>a wrapper for blas's daxpy routine. </p>
<p>a wrapper for lapack's DSYEVX routine.</p>
<p>a wrapper for lapack's DGESVD routine.</p>
<p>this is a wrapper for the following lapack routines:</p>
<p>heavily inspired by boost::enable_if <a href="http://www.boost.org,">http://www.boost.org,</a> file: boost/utility/enable_if.hpp, Copyright 2003 Jaakko Järvi, Jeremiah Willcock, Andrew Lumsdaine</p>
<p>a wrapper for blas's DOT routine.</p>
<p>a wrapper for blas's DGEMM routine.</p>
<p>SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY) .. Scalar Arguments .. DOUBLE PRECISION DA INTEGER INCX,INCY,N .. .. Array Arguments .. DOUBLE PRECISION DX(*),DY(*) ..</p>
<h1>Purpose </h1>
<p>DAXPY constant times a vector plus a vector. uses unrolled loops for increments equal to one.</p>
<p>more information in: <a href="http://netlib.org/blas/daxpy.f">http://netlib.org/blas/daxpy.f</a></p>
<p>SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) .. Scalar Arguments .. DOUBLE PRECISION ALPHA,BETA INTEGER K,LDA,LDB,LDC,M,N CHARACTER TRANSA,TRANSB .. .. Array Arguments .. DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*) ..</p>
<h1>Purpose </h1>
<p>DGEMM performs one of the matrix-matrix operations</p>
<p>C := alpha*op( A )*op( B ) + beta*C,</p>
<p>where op( X ) is one of</p>
<p>op( X ) = X or op( X ) = X**T,</p>
<p>alpha and beta are scalars, and A, B and C are matrices, with op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.</p>
<pre class="fragment">more information in: http://www.netlib.org/blas/dgemm.f
or http://www.netlib.org/clapack/cblas/dgemm.c</pre><p>REAL FUNCTION SDOT(N,SX,INCX,SY,INCY) .. Scalar Arguments .. INTEGER INCX,INCY,N</p>
<p>.. Array Arguments .. REAL SX(*),SY(*)</p>
<h1>Purpose </h1>
<p>SDOT forms the dot product of two vectors. uses unrolled loops for increments equal to one. *</p>
<p>more information in: <a href="http://netlib.org/blas/sdot.f">http://netlib.org/blas/sdot.f</a></p>
<p>xGESV</p>
<p>xGELS</p>
<p>returns a boolean to indicate success of the operation. if the return value is false, you can get the parameters using get_params(). error states:</p>
<p>INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if DBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of WORK above for details.</p>
<p>more information in: <a href="http://www.netlib.org/lapack/double/dgesvd.f">http://www.netlib.org/lapack/double/dgesvd.f</a></p>
<p>DSYEVX computes selected eigenvalues and, optionally, eigenvectors of a real symmetric matrix A. Eigenvalues and eigenvectors can be selected by specifying either a range of values or a range of indices for the desired eigenvalues.</p>
<p>returns a boolean to indicate success of the operation. if the return value is false, you can get the parameters using get_params(). error states:</p>
<p>INFO (output) INTEGER = 0: successful exit. &lt; 0: if INFO = -i, the i-th argument had an illegal value. &gt; 0: if DBDSQR did not converge, INFO specifies how many superdiagonals of an intermediate bidiagonal form B did not converge to zero. See the description of WORK above for details.</p>
<p>more information in: <a href="http://www.netlib.org/lapack/double/dsyevx.f">http://www.netlib.org/lapack/double/dsyevx.f</a> (see also: <a href="http://www.netlib.org/lapack/double/dsyev.f">http://www.netlib.org/lapack/double/dsyev.f</a> , but needs more space) </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a05f348b4b4ea27b94f7c0a69c8a2fd27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vmml::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">                VMMLIB_ERROR( <span class="stringliteral">&quot;Tensor4: set() not implemented for non-row major&quot;</span>, VMMLIB_HERE )</div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="tensor4_8hpp_source.html#l00441">441</a> of file <a class="el" href="tensor4_8hpp_source.html">tensor4.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacevmml.html">vmml</a></li>
    <li class="footer">Generated on Thu Oct 2 2014 13:33:13 for vmmlib by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
