<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - Pression - pression/compressor/zstd/lib/compress/fse_compress.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">pression/compressor/zstd/lib/compress</a> - fse_compress.c<span style="font-size: 80%;"> (source / <a href="fse_compress.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">Pression</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">333</td>
            <td class="headerCovTableEntry">384</td>
            <td class="headerCovTableEntryHi">86.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-11-11 05:39:51</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntry">24</td>
            <td class="headerCovTableEntryHi">83.3 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* ******************************************************************</a>
<span class="lineNum">       2 </span>            :    FSE : Finite State Entropy encoder
<span class="lineNum">       3 </span>            :    Copyright (C) 2013-2015, Yann Collet.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            :    BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :    Redistribution and use in source and binary forms, with or without
<span class="lineNum">       8 </span>            :    modification, are permitted provided that the following conditions are
<span class="lineNum">       9 </span>            :    met:
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            :        * Redistributions of source code must retain the above copyright
<span class="lineNum">      12 </span>            :    notice, this list of conditions and the following disclaimer.
<span class="lineNum">      13 </span>            :        * Redistributions in binary form must reproduce the above
<span class="lineNum">      14 </span>            :    copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      15 </span>            :    in the documentation and/or other materials provided with the
<span class="lineNum">      16 </span>            :    distribution.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            :    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      19 </span>            :    &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      20 </span>            :    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      21 </span>            :    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      22 </span>            :    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      23 </span>            :    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      24 </span>            :    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      25 </span>            :    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      26 </span>            :    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      27 </span>            :    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      28 </span>            :    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            :     You can contact the author at :
<span class="lineNum">      31 </span>            :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy
<span class="lineNum">      32 </span>            :     - Public forum : https://groups.google.com/forum/#!forum/lz4c
<span class="lineNum">      33 </span>            : ****************************************************************** */
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /* **************************************************************
<span class="lineNum">      36 </span>            : *  Compiler specifics
<span class="lineNum">      37 </span>            : ****************************************************************/
<span class="lineNum">      38 </span>            : #ifdef _MSC_VER    /* Visual Studio */
<span class="lineNum">      39 </span>            : #  define FORCE_INLINE static __forceinline
<span class="lineNum">      40 </span>            : #  include &lt;intrin.h&gt;                    /* For Visual 2005 */
<span class="lineNum">      41 </span>            : #  pragma warning(disable : 4127)        /* disable: C4127: conditional expression is constant */
<span class="lineNum">      42 </span>            : #  pragma warning(disable : 4214)        /* disable: C4214: non-int bitfields */
<span class="lineNum">      43 </span>            : #else
<span class="lineNum">      44 </span>            : #  if defined (__cplusplus) || defined (__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L   /* C99 */
<span class="lineNum">      45 </span>            : #    ifdef __GNUC__
<span class="lineNum">      46 </span>            : #      define FORCE_INLINE static inline __attribute__((always_inline))
<span class="lineNum">      47 </span>            : #    else
<span class="lineNum">      48 </span>            : #      define FORCE_INLINE static inline
<span class="lineNum">      49 </span>            : #    endif
<span class="lineNum">      50 </span>            : #  else
<span class="lineNum">      51 </span>            : #    define FORCE_INLINE static
<span class="lineNum">      52 </span>            : #  endif /* __STDC_VERSION__ */
<span class="lineNum">      53 </span>            : #endif
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /* **************************************************************
<span class="lineNum">      57 </span>            : *  Includes
<span class="lineNum">      58 </span>            : ****************************************************************/
<span class="lineNum">      59 </span>            : #include &lt;stdlib.h&gt;     /* malloc, free, qsort */
<span class="lineNum">      60 </span>            : #include &lt;string.h&gt;     /* memcpy, memset */
<span class="lineNum">      61 </span>            : #include &lt;stdio.h&gt;      /* printf (debug) */
<span class="lineNum">      62 </span>            : #include &quot;bitstream.h&quot;
<span class="lineNum">      63 </span>            : #define FSE_STATIC_LINKING_ONLY
<span class="lineNum">      64 </span>            : #include &quot;fse.h&quot;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* **************************************************************
<span class="lineNum">      68 </span>            : *  Error Management
<span class="lineNum">      69 </span>            : ****************************************************************/
<span class="lineNum">      70 </span>            : #define FSE_STATIC_ASSERT(c) { enum { FSE_static_assert = 1/(int)(!!(c)) }; }   /* use only *after* variable declarations */
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /* **************************************************************
<span class="lineNum">      74 </span>            : *  Complex types
<span class="lineNum">      75 </span>            : ****************************************************************/
<span class="lineNum">      76 </span>            : typedef U32 CTable_max_t[FSE_CTABLE_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)];
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /* **************************************************************
<span class="lineNum">      80 </span>            : *  Templates
<span class="lineNum">      81 </span>            : ****************************************************************/
<span class="lineNum">      82 </span>            : /*
<span class="lineNum">      83 </span>            :   designed to be included
<span class="lineNum">      84 </span>            :   for type-specific functions (template emulation in C)
<span class="lineNum">      85 </span>            :   Objective is to write these functions only once, for improved maintenance
<span class="lineNum">      86 </span>            : */
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /* safety checks */
<span class="lineNum">      89 </span>            : #ifndef FSE_FUNCTION_EXTENSION
<span class="lineNum">      90 </span>            : #  error &quot;FSE_FUNCTION_EXTENSION must be defined&quot;
<span class="lineNum">      91 </span>            : #endif
<span class="lineNum">      92 </span>            : #ifndef FSE_FUNCTION_TYPE
<span class="lineNum">      93 </span>            : #  error &quot;FSE_FUNCTION_TYPE must be defined&quot;
<span class="lineNum">      94 </span>            : #endif
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            : /* Function names */
<span class="lineNum">      97 </span>            : #define FSE_CAT(X,Y) X##Y
<span class="lineNum">      98 </span>            : #define FSE_FUNCTION_NAME(X,Y) FSE_CAT(X,Y)
<span class="lineNum">      99 </span>            : #define FSE_TYPE_NAME(X,Y) FSE_CAT(X,Y)
<span class="lineNum">     100 </span>            : 
<a name="101"><span class="lineNum">     101 </span>            : </a>
<span class="lineNum">     102 </span>            : /* Function templates */
<span class="lineNum">     103 </span><span class="lineCov">       8760 : size_t FSE_buildCTable(FSE_CTable* ct, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)</span>
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span><span class="lineCov">       8760 :     U32 const tableSize = 1 &lt;&lt; tableLog;</span>
<span class="lineNum">     106 </span><span class="lineCov">       8760 :     U32 const tableMask = tableSize - 1;</span>
<span class="lineNum">     107 </span><span class="lineCov">       8760 :     void* const ptr = ct;</span>
<span class="lineNum">     108 </span><span class="lineCov">       8760 :     U16* const tableU16 = ( (U16*) ptr) + 2;</span>
<span class="lineNum">     109 </span><span class="lineCov">       8760 :     void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableLog ? tableSize&gt;&gt;1 : 1) ;</span>
<span class="lineNum">     110 </span><span class="lineCov">       8760 :     FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);</span>
<span class="lineNum">     111 </span><span class="lineCov">       8760 :     U32 const step = FSE_TABLESTEP(tableSize);</span>
<span class="lineNum">     112 </span>            :     U32 cumul[FSE_MAX_SYMBOL_VALUE+2];
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :     FSE_FUNCTION_TYPE tableSymbol[FSE_MAX_TABLESIZE]; /* memset() is not necessary, even if static analyzer complain about it */
<span class="lineNum">     115 </span><span class="lineCov">       8760 :     U32 highThreshold = tableSize-1;</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :     /* CTable header */
<span class="lineNum">     118 </span><span class="lineCov">       8760 :     tableU16[-2] = (U16) tableLog;</span>
<span class="lineNum">     119 </span><span class="lineCov">       8760 :     tableU16[-1] = (U16) maxSymbolValue;</span>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :     /* For explanations on how to distribute symbol values over the table :
<span class="lineNum">     122 </span>            :     *  http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html */
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :     /* symbol start positions */
<span class="lineNum">     125 </span>            :     {   U32 u;
<span class="lineNum">     126 </span><span class="lineCov">       8760 :         cumul[0] = 0;</span>
<span class="lineNum">     127 </span><span class="lineCov">     194510 :         for (u=1; u&lt;=maxSymbolValue+1; u++) {</span>
<span class="lineNum">     128 </span><span class="lineCov">     185750 :             if (normalizedCounter[u-1]==-1) {  /* Low proba symbol */</span>
<span class="lineNum">     129 </span><span class="lineCov">      47618 :                 cumul[u] = cumul[u-1] + 1;</span>
<span class="lineNum">     130 </span><span class="lineCov">      47618 :                 tableSymbol[highThreshold--] = (FSE_FUNCTION_TYPE)(u-1);</span>
<span class="lineNum">     131 </span>            :             } else {
<span class="lineNum">     132 </span><span class="lineCov">     138132 :                 cumul[u] = cumul[u-1] + normalizedCounter[u-1];</span>
<span class="lineNum">     133 </span>            :         }   }
<span class="lineNum">     134 </span><span class="lineCov">       8760 :         cumul[maxSymbolValue+1] = tableSize+1;</span>
<span class="lineNum">     135 </span>            :     }
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     /* Spread symbols */
<span class="lineNum">     138 </span><span class="lineCov">       8760 :     {   U32 position = 0;</span>
<span class="lineNum">     139 </span>            :         U32 symbol;
<span class="lineNum">     140 </span><span class="lineCov">     194510 :         for (symbol=0; symbol&lt;=maxSymbolValue; symbol++) {</span>
<span class="lineNum">     141 </span>            :             int nbOccurences;
<span class="lineNum">     142 </span><span class="lineCov">    2748948 :             for (nbOccurences=0; nbOccurences&lt;normalizedCounter[symbol]; nbOccurences++) {</span>
<span class="lineNum">     143 </span><span class="lineCov">    2563198 :                 tableSymbol[position] = (FSE_FUNCTION_TYPE)symbol;</span>
<span class="lineNum">     144 </span><span class="lineCov">    2563198 :                 position = (position + step) &amp; tableMask;</span>
<span class="lineNum">     145 </span><span class="lineCov">    2563198 :                 while (position &gt; highThreshold) position = (position + step) &amp; tableMask;   /* Low proba area */</span>
<span class="lineNum">     146 </span>            :         }   }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineCov">       8760 :         if (position!=0) return ERROR(GENERIC);   /* Must have gone through all positions */</span>
<span class="lineNum">     149 </span>            :     }
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :     /* Build table */
<span class="lineNum">     152 </span><span class="lineCov">    2619576 :     {   U32 u; for (u=0; u&lt;tableSize; u++) {</span>
<span class="lineNum">     153 </span><span class="lineCov">    2610816 :         FSE_FUNCTION_TYPE s = tableSymbol[u];   /* note : static analyzer may not understand tableSymbol is properly initialized */</span>
<span class="lineNum">     154 </span><span class="lineCov">    2610816 :         tableU16[cumul[s]++] = (U16) (tableSize+u);   /* TableU16 : sorted by symbol order; gives next state value */</span>
<span class="lineNum">     155 </span>            :     }   }
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :     /* Build Symbol Transformation Table */
<span class="lineNum">     158 </span><span class="lineCov">       8760 :     {   unsigned total = 0;</span>
<span class="lineNum">     159 </span>            :         unsigned s;
<span class="lineNum">     160 </span><span class="lineCov">     194510 :         for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     161 </span><span class="lineCov">     185750 :             switch (normalizedCounter[s])</span>
<span class="lineNum">     162 </span>            :             {
<span class="lineNum">     163 </span><span class="lineCov">      24512 :             case  0: break;</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :             case -1:
<span class="lineNum">     166 </span>            :             case  1:
<span class="lineNum">     167 </span><span class="lineCov">      60426 :                 symbolTT[s].deltaNbBits = (tableLog &lt;&lt; 16) - (1&lt;&lt;tableLog);</span>
<span class="lineNum">     168 </span><span class="lineCov">      60426 :                 symbolTT[s].deltaFindState = total - 1;</span>
<span class="lineNum">     169 </span><span class="lineCov">      60426 :                 total ++;</span>
<span class="lineNum">     170 </span><span class="lineCov">      60426 :                 break;</span>
<span class="lineNum">     171 </span>            :             default :
<span class="lineNum">     172 </span>            :                 {
<span class="lineNum">     173 </span><span class="lineCov">     100812 :                     U32 const maxBitsOut = tableLog - BIT_highbit32 (normalizedCounter[s]-1);</span>
<span class="lineNum">     174 </span><span class="lineCov">     100812 :                     U32 const minStatePlus = normalizedCounter[s] &lt;&lt; maxBitsOut;</span>
<span class="lineNum">     175 </span><span class="lineCov">     100812 :                     symbolTT[s].deltaNbBits = (maxBitsOut &lt;&lt; 16) - minStatePlus;</span>
<span class="lineNum">     176 </span><span class="lineCov">     100812 :                     symbolTT[s].deltaFindState = total - normalizedCounter[s];</span>
<span class="lineNum">     177 </span><span class="lineCov">     100812 :                     total +=  normalizedCounter[s];</span>
<span class="lineNum">     178 </span>            :     }   }   }   }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span><span class="lineCov">       8760 :     return 0;</span>
<span class="lineNum">     181 </span>            : }
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : #ifndef FSE_COMMONDEFS_ONLY
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : /*-**************************************************************
<a name="188"><span class="lineNum">     188 </span>            : *  FSE NCount encoding-decoding</a>
<span class="lineNum">     189 </span>            : ****************************************************************/
<span class="lineNum">     190 </span><span class="lineCov">       8616 : size_t FSE_NCountWriteBound(unsigned maxSymbolValue, unsigned tableLog)</span>
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span><span class="lineCov">       8616 :     size_t maxHeaderSize = (((maxSymbolValue+1) * tableLog) &gt;&gt; 3) + 3;</span>
<span class="lineNum">     193 </span><span class="lineCov">       8616 :     return maxSymbolValue ? maxHeaderSize : FSE_NCOUNTBOUND;  /* maxSymbolValue==0 ? use default */</span>
<a name="194"><span class="lineNum">     194 </span>            : }</a>
<span class="lineNum">     195 </span>            : 
<a name="196"><span class="lineNum">     196 </span><span class="lineCov">     169736 : static short FSE_abs(short a) { return (short)(a&lt;0 ? -a : a); }</span></a>
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineCov">       8616 : static size_t FSE_writeNCount_generic (void* header, size_t headerBufferSize,</span>
<span class="lineNum">     199 </span>            :                                        const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog,
<span class="lineNum">     200 </span>            :                                        unsigned writeIsSafe)
<span class="lineNum">     201 </span>            : {
<span class="lineNum">     202 </span><span class="lineCov">       8616 :     BYTE* const ostart = (BYTE*) header;</span>
<span class="lineNum">     203 </span><span class="lineCov">       8616 :     BYTE* out = ostart;</span>
<span class="lineNum">     204 </span><span class="lineCov">       8616 :     BYTE* const oend = ostart + headerBufferSize;</span>
<span class="lineNum">     205 </span>            :     int nbBits;
<span class="lineNum">     206 </span><span class="lineCov">       8616 :     const int tableSize = 1 &lt;&lt; tableLog;</span>
<span class="lineNum">     207 </span>            :     int remaining;
<span class="lineNum">     208 </span>            :     int threshold;
<span class="lineNum">     209 </span>            :     U32 bitStream;
<span class="lineNum">     210 </span>            :     int bitCount;
<span class="lineNum">     211 </span><span class="lineCov">       8616 :     unsigned charnum = 0;</span>
<span class="lineNum">     212 </span><span class="lineCov">       8616 :     int previous0 = 0;</span>
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span><span class="lineCov">       8616 :     bitStream = 0;</span>
<span class="lineNum">     215 </span><span class="lineCov">       8616 :     bitCount  = 0;</span>
<span class="lineNum">     216 </span>            :     /* Table Size */
<span class="lineNum">     217 </span><span class="lineCov">       8616 :     bitStream += (tableLog-FSE_MIN_TABLELOG) &lt;&lt; bitCount;</span>
<span class="lineNum">     218 </span><span class="lineCov">       8616 :     bitCount  += 4;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     /* Init */
<span class="lineNum">     221 </span><span class="lineCov">       8616 :     remaining = tableSize+1;   /* +1 for extra accuracy */</span>
<span class="lineNum">     222 </span><span class="lineCov">       8616 :     threshold = tableSize;</span>
<span class="lineNum">     223 </span><span class="lineCov">       8616 :     nbBits = tableLog+1;</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span><span class="lineCov">     186968 :     while (remaining&gt;1) {  /* stops at 1 */</span>
<span class="lineNum">     226 </span><span class="lineCov">     169736 :         if (previous0) {</span>
<span class="lineNum">     227 </span><span class="lineCov">      14224 :             unsigned start = charnum;</span>
<span class="lineNum">     228 </span><span class="lineCov">      14224 :             while (!normalizedCounter[charnum]) charnum++;</span>
<span class="lineNum">     229 </span><span class="lineCov">      28466 :             while (charnum &gt;= start+24) {</span>
<span class="lineNum">     230 </span><span class="lineCov">         18 :                 start+=24;</span>
<span class="lineNum">     231 </span><span class="lineCov">         18 :                 bitStream += 0xFFFFU &lt;&lt; bitCount;</span>
<span class="lineNum">     232 </span><span class="lineCov">         18 :                 if ((!writeIsSafe) &amp;&amp; (out &gt; oend-2)) return ERROR(dstSize_tooSmall);   /* Buffer overflow */</span>
<span class="lineNum">     233 </span><span class="lineCov">         18 :                 out[0] = (BYTE) bitStream;</span>
<span class="lineNum">     234 </span><span class="lineCov">         18 :                 out[1] = (BYTE)(bitStream&gt;&gt;8);</span>
<span class="lineNum">     235 </span><span class="lineCov">         18 :                 out+=2;</span>
<span class="lineNum">     236 </span><span class="lineCov">         18 :                 bitStream&gt;&gt;=16;</span>
<span class="lineNum">     237 </span>            :             }
<span class="lineNum">     238 </span><span class="lineCov">      30042 :             while (charnum &gt;= start+3) {</span>
<span class="lineNum">     239 </span><span class="lineCov">       1594 :                 start+=3;</span>
<span class="lineNum">     240 </span><span class="lineCov">       1594 :                 bitStream += 3 &lt;&lt; bitCount;</span>
<span class="lineNum">     241 </span><span class="lineCov">       1594 :                 bitCount += 2;</span>
<span class="lineNum">     242 </span>            :             }
<span class="lineNum">     243 </span><span class="lineCov">      14224 :             bitStream += (charnum-start) &lt;&lt; bitCount;</span>
<span class="lineNum">     244 </span><span class="lineCov">      14224 :             bitCount += 2;</span>
<span class="lineNum">     245 </span><span class="lineCov">      14224 :             if (bitCount&gt;16) {</span>
<span class="lineNum">     246 </span><span class="lineCov">       1860 :                 if ((!writeIsSafe) &amp;&amp; (out &gt; oend - 2)) return ERROR(dstSize_tooSmall);   /* Buffer overflow */</span>
<span class="lineNum">     247 </span><span class="lineCov">       1860 :                 out[0] = (BYTE)bitStream;</span>
<span class="lineNum">     248 </span><span class="lineCov">       1860 :                 out[1] = (BYTE)(bitStream&gt;&gt;8);</span>
<span class="lineNum">     249 </span><span class="lineCov">       1860 :                 out += 2;</span>
<span class="lineNum">     250 </span><span class="lineCov">       1860 :                 bitStream &gt;&gt;= 16;</span>
<span class="lineNum">     251 </span><span class="lineCov">       1860 :                 bitCount -= 16;</span>
<span class="lineNum">     252 </span>            :         }   }
<span class="lineNum">     253 </span><span class="lineCov">     169736 :         {   short count = normalizedCounter[charnum++];</span>
<span class="lineNum">     254 </span><span class="lineCov">     169736 :             const short max = (short)((2*threshold-1)-remaining);</span>
<span class="lineNum">     255 </span><span class="lineCov">     169736 :             remaining -= FSE_abs(count);</span>
<span class="lineNum">     256 </span><span class="lineCov">     169736 :             if (remaining&lt;1) return ERROR(GENERIC);</span>
<span class="lineNum">     257 </span><span class="lineCov">     169736 :             count++;   /* +1 for extra accuracy */</span>
<span class="lineNum">     258 </span><span class="lineCov">     169736 :             if (count&gt;=threshold) count += max;   /* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */</span>
<span class="lineNum">     259 </span><span class="lineCov">     169736 :             bitStream += count &lt;&lt; bitCount;</span>
<span class="lineNum">     260 </span><span class="lineCov">     169736 :             bitCount  += nbBits;</span>
<span class="lineNum">     261 </span><span class="lineCov">     169736 :             bitCount  -= (count&lt;max);</span>
<span class="lineNum">     262 </span><span class="lineCov">     169736 :             previous0  = (count==1);</span>
<span class="lineNum">     263 </span><span class="lineCov">     169736 :             while (remaining&lt;threshold) nbBits--, threshold&gt;&gt;=1;</span>
<span class="lineNum">     264 </span>            :         }
<span class="lineNum">     265 </span><span class="lineCov">     169736 :         if (bitCount&gt;16) {</span>
<span class="lineNum">     266 </span><span class="lineCov">      49814 :             if ((!writeIsSafe) &amp;&amp; (out &gt; oend - 2)) return ERROR(dstSize_tooSmall);   /* Buffer overflow */</span>
<span class="lineNum">     267 </span><span class="lineCov">      49814 :             out[0] = (BYTE)bitStream;</span>
<span class="lineNum">     268 </span><span class="lineCov">      49814 :             out[1] = (BYTE)(bitStream&gt;&gt;8);</span>
<span class="lineNum">     269 </span><span class="lineCov">      49814 :             out += 2;</span>
<span class="lineNum">     270 </span><span class="lineCov">      49814 :             bitStream &gt;&gt;= 16;</span>
<span class="lineNum">     271 </span><span class="lineCov">      49814 :             bitCount -= 16;</span>
<span class="lineNum">     272 </span>            :     }   }
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :     /* flush remaining bitStream */
<span class="lineNum">     275 </span><span class="lineCov">       8616 :     if ((!writeIsSafe) &amp;&amp; (out &gt; oend - 2)) return ERROR(dstSize_tooSmall);   /* Buffer overflow */</span>
<span class="lineNum">     276 </span><span class="lineCov">       8616 :     out[0] = (BYTE)bitStream;</span>
<span class="lineNum">     277 </span><span class="lineCov">       8616 :     out[1] = (BYTE)(bitStream&gt;&gt;8);</span>
<span class="lineNum">     278 </span><span class="lineCov">       8616 :     out+= (bitCount+7) /8;</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">       8616 :     if (charnum &gt; maxSymbolValue + 1) return ERROR(GENERIC);</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">       8616 :     return (out-ostart);</span>
<span class="lineNum">     283 </span>            : }
<a name="284"><span class="lineNum">     284 </span>            : </a>
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span><span class="lineCov">       8616 : size_t FSE_writeNCount (void* buffer, size_t bufferSize, const short* normalizedCounter, unsigned maxSymbolValue, unsigned tableLog)</span>
<span class="lineNum">     287 </span>            : {
<span class="lineNum">     288 </span><span class="lineCov">       8616 :     if (tableLog &gt; FSE_MAX_TABLELOG) return ERROR(GENERIC);   /* Unsupported */</span>
<span class="lineNum">     289 </span><span class="lineCov">       8616 :     if (tableLog &lt; FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported */</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">       8616 :     if (bufferSize &lt; FSE_NCountWriteBound(maxSymbolValue, tableLog))</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 0);</span>
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span><span class="lineCov">       8616 :     return FSE_writeNCount_generic(buffer, bufferSize, normalizedCounter, maxSymbolValue, tableLog, 1);</span>
<span class="lineNum">     295 </span>            : }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : /*-**************************************************************
<span class="lineNum">     300 </span>            : *  Counting histogram
<span class="lineNum">     301 </span>            : ****************************************************************/
<span class="lineNum">     302 </span>            : /*! FSE_count_simple
<span class="lineNum">     303 </span>            :     This function just counts byte values within `src`,
<span class="lineNum">     304 </span>            :     and store the histogram into table `count`.
<span class="lineNum">     305 </span>            :     This function is unsafe : it doesn't check that all values within `src` can fit into `count`.
<span class="lineNum">     306 </span>            :     For this reason, prefer using a table `count` with 256 elements.
<a name="307"><span class="lineNum">     307 </span>            :     @return : count of most numerous element</a>
<span class="lineNum">     308 </span>            : */
<span class="lineNum">     309 </span><span class="lineCov">       3024 : static size_t FSE_count_simple(unsigned* count, unsigned* maxSymbolValuePtr,</span>
<span class="lineNum">     310 </span>            :                                const void* src, size_t srcSize)
<span class="lineNum">     311 </span>            : {
<span class="lineNum">     312 </span><span class="lineCov">       3024 :     const BYTE* ip = (const BYTE*)src;</span>
<span class="lineNum">     313 </span><span class="lineCov">       3024 :     const BYTE* const end = ip + srcSize;</span>
<span class="lineNum">     314 </span><span class="lineCov">       3024 :     unsigned maxSymbolValue = *maxSymbolValuePtr;</span>
<span class="lineNum">     315 </span><span class="lineCov">       3024 :     unsigned max=0;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineCov">       3024 :     memset(count, 0, (maxSymbolValue+1)*sizeof(*count));</span>
<span class="lineNum">     319 </span><span class="lineCov">       3024 :     if (srcSize==0) { *maxSymbolValuePtr = 0; return 0; }</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineCov">       3024 :     while (ip&lt;end) count[*ip++]++;</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineCov">       3024 :     while (!count[maxSymbolValue]) maxSymbolValue--;</span>
<span class="lineNum">     324 </span><span class="lineCov">       3024 :     *maxSymbolValuePtr = maxSymbolValue;</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineCov">       3024 :     { U32 s; for (s=0; s&lt;=maxSymbolValue; s++) if (count[s] &gt; max) max = count[s]; }</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span><span class="lineCov">       3024 :     return (size_t)max;</span>
<span class="lineNum">     329 </span>            : }
<a name="330"><span class="lineNum">     330 </span>            : </a>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineCov">       9886 : static size_t FSE_count_parallel(unsigned* count, unsigned* maxSymbolValuePtr,</span>
<span class="lineNum">     333 </span>            :                                 const void* source, size_t sourceSize,
<span class="lineNum">     334 </span>            :                                 unsigned checkMax)
<span class="lineNum">     335 </span>            : {
<span class="lineNum">     336 </span><span class="lineCov">       9886 :     const BYTE* ip = (const BYTE*)source;</span>
<span class="lineNum">     337 </span><span class="lineCov">       9886 :     const BYTE* const iend = ip+sourceSize;</span>
<span class="lineNum">     338 </span><span class="lineCov">       9886 :     unsigned maxSymbolValue = *maxSymbolValuePtr;</span>
<span class="lineNum">     339 </span><span class="lineCov">       9886 :     unsigned max=0;</span>
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span><span class="lineCov">       9886 :     U32 Counting1[256] = { 0 };</span>
<span class="lineNum">     343 </span><span class="lineCov">       9886 :     U32 Counting2[256] = { 0 };</span>
<span class="lineNum">     344 </span><span class="lineCov">       9886 :     U32 Counting3[256] = { 0 };</span>
<span class="lineNum">     345 </span><span class="lineCov">       9886 :     U32 Counting4[256] = { 0 };</span>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            :     /* safety checks */
<span class="lineNum">     348 </span><span class="lineCov">       9886 :     if (!sourceSize) {</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :         memset(count, 0, maxSymbolValue + 1);</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :         *maxSymbolValuePtr = 0;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     352 </span>            :     }
<span class="lineNum">     353 </span><span class="lineCov">       9886 :     if (!maxSymbolValue) maxSymbolValue = 255;            /* 0 == default */</span>
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :     /* by stripes of 16 bytes */
<span class="lineNum">     356 </span><span class="lineCov">       9886 :     {   U32 cached = MEM_read32(ip); ip += 4;</span>
<span class="lineNum">     357 </span><span class="lineCov">   23740312 :         while (ip &lt; iend-15) {</span>
<span class="lineNum">     358 </span><span class="lineCov">   23720540 :             U32 c = cached; cached = MEM_read32(ip); ip += 4;</span>
<span class="lineNum">     359 </span><span class="lineCov">   23720540 :             Counting1[(BYTE) c     ]++;</span>
<span class="lineNum">     360 </span><span class="lineCov">   23720540 :             Counting2[(BYTE)(c&gt;&gt;8) ]++;</span>
<span class="lineNum">     361 </span><span class="lineCov">   23720540 :             Counting3[(BYTE)(c&gt;&gt;16)]++;</span>
<span class="lineNum">     362 </span><span class="lineCov">   23720540 :             Counting4[       c&gt;&gt;24 ]++;</span>
<span class="lineNum">     363 </span><span class="lineCov">   23720540 :             c = cached; cached = MEM_read32(ip); ip += 4;</span>
<span class="lineNum">     364 </span><span class="lineCov">   23720540 :             Counting1[(BYTE) c     ]++;</span>
<span class="lineNum">     365 </span><span class="lineCov">   23720540 :             Counting2[(BYTE)(c&gt;&gt;8) ]++;</span>
<span class="lineNum">     366 </span><span class="lineCov">   23720540 :             Counting3[(BYTE)(c&gt;&gt;16)]++;</span>
<span class="lineNum">     367 </span><span class="lineCov">   23720540 :             Counting4[       c&gt;&gt;24 ]++;</span>
<span class="lineNum">     368 </span><span class="lineCov">   23720540 :             c = cached; cached = MEM_read32(ip); ip += 4;</span>
<span class="lineNum">     369 </span><span class="lineCov">   23720540 :             Counting1[(BYTE) c     ]++;</span>
<span class="lineNum">     370 </span><span class="lineCov">   23720540 :             Counting2[(BYTE)(c&gt;&gt;8) ]++;</span>
<span class="lineNum">     371 </span><span class="lineCov">   23720540 :             Counting3[(BYTE)(c&gt;&gt;16)]++;</span>
<span class="lineNum">     372 </span><span class="lineCov">   23720540 :             Counting4[       c&gt;&gt;24 ]++;</span>
<span class="lineNum">     373 </span><span class="lineCov">   23720540 :             c = cached; cached = MEM_read32(ip); ip += 4;</span>
<span class="lineNum">     374 </span><span class="lineCov">   23720540 :             Counting1[(BYTE) c     ]++;</span>
<span class="lineNum">     375 </span><span class="lineCov">   23720540 :             Counting2[(BYTE)(c&gt;&gt;8) ]++;</span>
<span class="lineNum">     376 </span><span class="lineCov">   23720540 :             Counting3[(BYTE)(c&gt;&gt;16)]++;</span>
<span class="lineNum">     377 </span><span class="lineCov">   23720540 :             Counting4[       c&gt;&gt;24 ]++;</span>
<span class="lineNum">     378 </span>            :         }
<span class="lineNum">     379 </span><span class="lineCov">       9886 :         ip-=4;</span>
<span class="lineNum">     380 </span>            :     }
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :     /* finish last symbols */
<span class="lineNum">     383 </span><span class="lineCov">       9886 :     while (ip&lt;iend) Counting1[*ip++]++;</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineCov">       9886 :     if (checkMax) {   /* verify stats will fit into destination table */</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         U32 s; for (s=255; s&gt;maxSymbolValue; s--) {</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :             Counting1[s] += Counting2[s] + Counting3[s] + Counting4[s];</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :             if (Counting1[s]) return ERROR(maxSymbolValue_tooSmall);</span>
<span class="lineNum">     389 </span>            :     }   }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span><span class="lineCov">    1273202 :     { U32 s; for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     392 </span><span class="lineCov">    1263316 :         count[s] = Counting1[s] + Counting2[s] + Counting3[s] + Counting4[s];</span>
<span class="lineNum">     393 </span><span class="lineCov">    1263316 :         if (count[s] &gt; max) max = count[s];</span>
<span class="lineNum">     394 </span>            :     }}
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">       9886 :     while (!count[maxSymbolValue]) maxSymbolValue--;</span>
<span class="lineNum">     397 </span><span class="lineCov">       9886 :     *maxSymbolValuePtr = maxSymbolValue;</span>
<span class="lineNum">     398 </span><span class="lineCov">       9886 :     return (size_t)max;</span>
<span class="lineNum">     399 </span>            : }
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : /* fast variant (unsafe : won't check if src contains values beyond count[] limit) */
<span class="lineNum">     402 </span><span class="lineCov">      12910 : size_t FSE_countFast(unsigned* count, unsigned* maxSymbolValuePtr,</span>
<span class="lineNum">     403 </span>            :                      const void* source, size_t sourceSize)
<span class="lineNum">     404 </span>            : {
<span class="lineNum">     405 </span><span class="lineCov">      12910 :     if (sourceSize &lt; 1500) return FSE_count_simple(count, maxSymbolValuePtr, source, sourceSize);</span>
<span class="lineNum">     406 </span><span class="lineCov">       9886 :     return FSE_count_parallel(count, maxSymbolValuePtr, source, sourceSize, 0);</span>
<a name="407"><span class="lineNum">     407 </span>            : }</a>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineCov">       6448 : size_t FSE_count(unsigned* count, unsigned* maxSymbolValuePtr,</span>
<span class="lineNum">     410 </span>            :                  const void* source, size_t sourceSize)
<span class="lineNum">     411 </span>            : {
<span class="lineNum">     412 </span><span class="lineCov">       6448 :     if (*maxSymbolValuePtr &lt;255)</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         return FSE_count_parallel(count, maxSymbolValuePtr, source, sourceSize, 1);</span>
<span class="lineNum">     414 </span><span class="lineCov">       6448 :     *maxSymbolValuePtr = 255;</span>
<span class="lineNum">     415 </span><span class="lineCov">       6448 :     return FSE_countFast(count, maxSymbolValuePtr, source, sourceSize);</span>
<span class="lineNum">     416 </span>            : }
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : /*-**************************************************************
<span class="lineNum">     421 </span>            : *  FSE Compression Code
<span class="lineNum">     422 </span>            : ****************************************************************/
<span class="lineNum">     423 </span>            : /*! FSE_sizeof_CTable() :
<span class="lineNum">     424 </span>            :     FSE_CTable is a variable size structure which contains :
<span class="lineNum">     425 </span>            :     `U16 tableLog;`
<span class="lineNum">     426 </span>            :     `U16 maxSymbolValue;`
<span class="lineNum">     427 </span>            :     `U16 nextStateNumber[1 &lt;&lt; tableLog];`                         // This size is variable
<span class="lineNum">     428 </span>            :     `FSE_symbolCompressionTransform symbolTT[maxSymbolValue+1];`  // This size is variable
<span class="lineNum">     429 </span>            : Allocation is manual (C standard does not support variable-size structures).
<a name="430"><span class="lineNum">     430 </span>            : */</a>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineNoCov">          0 : size_t FSE_sizeof_CTable (unsigned maxSymbolValue, unsigned tableLog)</span>
<span class="lineNum">     433 </span>            : {
<span class="lineNum">     434 </span>            :     size_t size;
<span class="lineNum">     435 </span>            :     FSE_STATIC_ASSERT((size_t)FSE_CTABLE_SIZE_U32(FSE_MAX_TABLELOG, FSE_MAX_SYMBOL_VALUE)*4 &gt;= sizeof(CTable_max_t));   /* A compilation error here means FSE_CTABLE_SIZE_U32 is not large enough */
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :     if (tableLog &gt; FSE_MAX_TABLELOG) return ERROR(GENERIC);</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :     size = FSE_CTABLE_SIZE_U32 (tableLog, maxSymbolValue) * sizeof(U32);</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :     return size;</span>
<a name="439"><span class="lineNum">     439 </span>            : }</a>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineNoCov">          0 : FSE_CTable* FSE_createCTable (unsigned maxSymbolValue, unsigned tableLog)</span>
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span>            :     size_t size;
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :     if (tableLog &gt; FSE_TABLELOG_ABSOLUTE_MAX) tableLog = FSE_TABLELOG_ABSOLUTE_MAX;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     size = FSE_CTABLE_SIZE_U32 (tableLog, maxSymbolValue) * sizeof(U32);</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :     return (FSE_CTable*)malloc(size);</span>
<a name="447"><span class="lineNum">     447 </span>            : }</a>
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineNoCov">          0 : void FSE_freeCTable (FSE_CTable* ct) { free(ct); }</span>
<a name="450"><span class="lineNum">     450 </span>            : </a>
<span class="lineNum">     451 </span>            : /* provides the minimum logSize to safely represent a distribution */
<span class="lineNum">     452 </span><span class="lineCov">      19536 : static unsigned FSE_minTableLog(size_t srcSize, unsigned maxSymbolValue)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span><span class="lineCov">      19536 :         U32 minBitsSrc = BIT_highbit32((U32)(srcSize - 1)) + 1;</span>
<span class="lineNum">     455 </span><span class="lineCov">      19536 :         U32 minBitsSymbols = BIT_highbit32(maxSymbolValue) + 2;</span>
<span class="lineNum">     456 </span><span class="lineCov">      19536 :         U32 minBits = minBitsSrc &lt; minBitsSymbols ? minBitsSrc : minBitsSymbols;</span>
<span class="lineNum">     457 </span><span class="lineCov">      19536 :         return minBits;</span>
<a name="458"><span class="lineNum">     458 </span>            : }</a>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span><span class="lineCov">      10920 : unsigned FSE_optimalTableLog_internal(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue, unsigned minus)</span>
<span class="lineNum">     461 </span>            : {
<span class="lineNum">     462 </span><span class="lineCov">      10920 :         U32 maxBitsSrc = BIT_highbit32((U32)(srcSize - 1)) - minus;</span>
<span class="lineNum">     463 </span><span class="lineCov">      10920 :     U32 tableLog = maxTableLog;</span>
<span class="lineNum">     464 </span><span class="lineCov">      10920 :         U32 minBits = FSE_minTableLog(srcSize, maxSymbolValue);</span>
<span class="lineNum">     465 </span><span class="lineCov">      10920 :     if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;</span>
<span class="lineNum">     466 </span><span class="lineCov">      10920 :         if (maxBitsSrc &lt; tableLog) tableLog = maxBitsSrc;   /* Accuracy can be reduced */</span>
<span class="lineNum">     467 </span><span class="lineCov">      10920 :         if (minBits &gt; tableLog) tableLog = minBits;   /* Need a minimum to safely represent all symbol values */</span>
<span class="lineNum">     468 </span><span class="lineCov">      10920 :     if (tableLog &lt; FSE_MIN_TABLELOG) tableLog = FSE_MIN_TABLELOG;</span>
<span class="lineNum">     469 </span><span class="lineCov">      10920 :     if (tableLog &gt; FSE_MAX_TABLELOG) tableLog = FSE_MAX_TABLELOG;</span>
<span class="lineNum">     470 </span><span class="lineCov">      10920 :     return tableLog;</span>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">       8616 : unsigned FSE_optimalTableLog(unsigned maxTableLog, size_t srcSize, unsigned maxSymbolValue)</span>
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span><span class="lineCov">       8616 :     return FSE_optimalTableLog_internal(maxTableLog, srcSize, maxSymbolValue, 2);</span>
<span class="lineNum">     476 </span>            : }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            : /* Secondary normalization method.
<a name="480"><span class="lineNum">     480 </span>            :    To be used when primary method fails. */</a>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineCov">          8 : static size_t FSE_normalizeM2(short* norm, U32 tableLog, const unsigned* count, size_t total, U32 maxSymbolValue)</span>
<span class="lineNum">     483 </span>            : {
<span class="lineNum">     484 </span>            :     U32 s;
<span class="lineNum">     485 </span><span class="lineCov">          8 :     U32 distributed = 0;</span>
<span class="lineNum">     486 </span>            :     U32 ToDistribute;
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            :     /* Init */
<span class="lineNum">     489 </span><span class="lineCov">          8 :     U32 lowThreshold = (U32)(total &gt;&gt; tableLog);</span>
<span class="lineNum">     490 </span><span class="lineCov">          8 :     U32 lowOne = (U32)((total * 3) &gt;&gt; (tableLog + 1));</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineCov">        366 :     for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     493 </span><span class="lineCov">        358 :         if (count[s] == 0) {</span>
<span class="lineNum">     494 </span><span class="lineCov">         32 :             norm[s]=0;</span>
<span class="lineNum">     495 </span><span class="lineCov">         32 :             continue;</span>
<span class="lineNum">     496 </span>            :         }
<span class="lineNum">     497 </span><span class="lineCov">        326 :         if (count[s] &lt;= lowThreshold) {</span>
<span class="lineNum">     498 </span><span class="lineCov">        164 :             norm[s] = -1;</span>
<span class="lineNum">     499 </span><span class="lineCov">        164 :             distributed++;</span>
<span class="lineNum">     500 </span><span class="lineCov">        164 :             total -= count[s];</span>
<span class="lineNum">     501 </span><span class="lineCov">        164 :             continue;</span>
<span class="lineNum">     502 </span>            :         }
<span class="lineNum">     503 </span><span class="lineCov">        162 :         if (count[s] &lt;= lowOne) {</span>
<span class="lineNum">     504 </span><span class="lineCov">         30 :             norm[s] = 1;</span>
<span class="lineNum">     505 </span><span class="lineCov">         30 :             distributed++;</span>
<span class="lineNum">     506 </span><span class="lineCov">         30 :             total -= count[s];</span>
<span class="lineNum">     507 </span><span class="lineCov">         30 :             continue;</span>
<span class="lineNum">     508 </span>            :         }
<span class="lineNum">     509 </span><span class="lineCov">        132 :         norm[s]=-2;</span>
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span><span class="lineCov">          8 :     ToDistribute = (1 &lt;&lt; tableLog) - distributed;</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineCov">          8 :     if ((total / ToDistribute) &gt; lowOne) {</span>
<span class="lineNum">     514 </span>            :         /* risk of rounding to zero */
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :         lowOne = (U32)((total * 3) / (ToDistribute * 2));</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :             if ((norm[s] == -2) &amp;&amp; (count[s] &lt;= lowOne)) {</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                 norm[s] = 1;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                 distributed++;</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :                 total -= count[s];</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     522 </span>            :         }   }
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :         ToDistribute = (1 &lt;&lt; tableLog) - distributed;</span>
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">          8 :     if (distributed == maxSymbolValue+1) {</span>
<span class="lineNum">     527 </span>            :         /* all values are pretty poor;
<span class="lineNum">     528 </span>            :            probably incompressible data (should have already been detected);
<span class="lineNum">     529 </span>            :            find max, then give all remaining points to max */
<span class="lineNum">     530 </span><span class="lineNoCov">          0 :         U32 maxV = 0, maxC = 0;</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :         for (s=0; s&lt;=maxSymbolValue; s++)</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :             if (count[s] &gt; maxC) maxV=s, maxC=count[s];</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :         norm[maxV] += (short)ToDistribute;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     535 </span>            :     }
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span>            :     {
<span class="lineNum">     538 </span><span class="lineCov">          8 :         U64 const vStepLog = 62 - tableLog;</span>
<span class="lineNum">     539 </span><span class="lineCov">          8 :         U64 const mid = (1ULL &lt;&lt; (vStepLog-1)) - 1;</span>
<span class="lineNum">     540 </span><span class="lineCov">          8 :         U64 const rStep = ((((U64)1&lt;&lt;vStepLog) * ToDistribute) + mid) / total;   /* scale on remaining */</span>
<span class="lineNum">     541 </span><span class="lineCov">          8 :         U64 tmpTotal = mid;</span>
<span class="lineNum">     542 </span><span class="lineCov">        366 :         for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     543 </span><span class="lineCov">        358 :             if (norm[s]==-2) {</span>
<span class="lineNum">     544 </span><span class="lineCov">        132 :                 U64 end = tmpTotal + (count[s] * rStep);</span>
<span class="lineNum">     545 </span><span class="lineCov">        132 :                 U32 sStart = (U32)(tmpTotal &gt;&gt; vStepLog);</span>
<span class="lineNum">     546 </span><span class="lineCov">        132 :                 U32 sEnd = (U32)(end &gt;&gt; vStepLog);</span>
<span class="lineNum">     547 </span><span class="lineCov">        132 :                 U32 weight = sEnd - sStart;</span>
<span class="lineNum">     548 </span><span class="lineCov">        132 :                 if (weight &lt; 1)</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :                     return ERROR(GENERIC);</span>
<span class="lineNum">     550 </span><span class="lineCov">        132 :                 norm[s] = (short)weight;</span>
<span class="lineNum">     551 </span><span class="lineCov">        132 :                 tmpTotal = end;</span>
<span class="lineNum">     552 </span>            :     }   }   }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineCov">          8 :     return 0;</span>
<span class="lineNum">     555 </span>            : }
<a name="556"><span class="lineNum">     556 </span>            : </a>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineCov">       8616 : size_t FSE_normalizeCount (short* normalizedCounter, unsigned tableLog,</span>
<span class="lineNum">     559 </span>            :                            const unsigned* count, size_t total,
<span class="lineNum">     560 </span>            :                            unsigned maxSymbolValue)
<span class="lineNum">     561 </span>            : {
<span class="lineNum">     562 </span>            :     /* Sanity checks */
<span class="lineNum">     563 </span><span class="lineCov">       8616 :     if (tableLog==0) tableLog = FSE_DEFAULT_TABLELOG;</span>
<span class="lineNum">     564 </span><span class="lineCov">       8616 :     if (tableLog &lt; FSE_MIN_TABLELOG) return ERROR(GENERIC);   /* Unsupported size */</span>
<span class="lineNum">     565 </span><span class="lineCov">       8616 :     if (tableLog &gt; FSE_MAX_TABLELOG) return ERROR(tableLog_tooLarge);   /* Unsupported size */</span>
<span class="lineNum">     566 </span><span class="lineCov">       8616 :     if (tableLog &lt; FSE_minTableLog(total, maxSymbolValue)) return ERROR(GENERIC);   /* Too small tableLog, compression potentially impossible */</span>
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span><span class="lineCov">       8616 :     {   U32 const rtbTable[] = {     0, 473195, 504333, 520860, 550000, 700000, 750000, 830000 };</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">       8616 :         U64 const scale = 62 - tableLog;</span>
<span class="lineNum">     571 </span><span class="lineCov">       8616 :         U64 const step = ((U64)1&lt;&lt;62) / total;   /* &lt;== here, one division ! */</span>
<span class="lineNum">     572 </span><span class="lineCov">       8616 :         U64 const vStep = 1ULL&lt;&lt;(scale-20);</span>
<span class="lineNum">     573 </span><span class="lineCov">       8616 :         int stillToDistribute = 1&lt;&lt;tableLog;</span>
<span class="lineNum">     574 </span>            :         unsigned s;
<span class="lineNum">     575 </span><span class="lineCov">       8616 :         unsigned largest=0;</span>
<span class="lineNum">     576 </span><span class="lineCov">       8616 :         short largestP=0;</span>
<span class="lineNum">     577 </span><span class="lineCov">       8616 :         U32 lowThreshold = (U32)(total &gt;&gt; tableLog);</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">     188640 :         for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     580 </span><span class="lineCov">     180024 :             if (count[s] == total) return 0;   /* rle special case */</span>
<span class="lineNum">     581 </span><span class="lineCov">     180024 :             if (count[s] == 0) { normalizedCounter[s]=0; continue; }</span>
<span class="lineNum">     582 </span><span class="lineCov">     155512 :             if (count[s] &lt;= lowThreshold) {</span>
<span class="lineNum">     583 </span><span class="lineCov">      46848 :                 normalizedCounter[s] = -1;</span>
<span class="lineNum">     584 </span><span class="lineCov">      46848 :                 stillToDistribute--;</span>
<span class="lineNum">     585 </span>            :             } else {
<span class="lineNum">     586 </span><span class="lineCov">     108664 :                 short proba = (short)((count[s]*step) &gt;&gt; scale);</span>
<span class="lineNum">     587 </span><span class="lineCov">     108664 :                 if (proba&lt;8) {</span>
<span class="lineNum">     588 </span><span class="lineCov">      58416 :                     U64 restToBeat = vStep * rtbTable[proba];</span>
<span class="lineNum">     589 </span><span class="lineCov">      58416 :                     proba += (count[s]*step) - ((U64)proba&lt;&lt;scale) &gt; restToBeat;</span>
<span class="lineNum">     590 </span>            :                 }
<span class="lineNum">     591 </span><span class="lineCov">     108664 :                 if (proba &gt; largestP) largestP=proba, largest=s;</span>
<span class="lineNum">     592 </span><span class="lineCov">     108664 :                 normalizedCounter[s] = proba;</span>
<span class="lineNum">     593 </span><span class="lineCov">     108664 :                 stillToDistribute -= proba;</span>
<span class="lineNum">     594 </span>            :         }   }
<span class="lineNum">     595 </span><span class="lineCov">       8616 :         if (-stillToDistribute &gt;= (normalizedCounter[largest] &gt;&gt; 1)) {</span>
<span class="lineNum">     596 </span>            :             /* corner case, need another normalization method */
<span class="lineNum">     597 </span><span class="lineCov">          8 :             size_t errorCode = FSE_normalizeM2(normalizedCounter, tableLog, count, total, maxSymbolValue);</span>
<span class="lineNum">     598 </span><span class="lineCov">          8 :             if (FSE_isError(errorCode)) return errorCode;</span>
<span class="lineNum">     599 </span>            :         }
<span class="lineNum">     600 </span><span class="lineCov">       8608 :         else normalizedCounter[largest] += (short)stillToDistribute;</span>
<span class="lineNum">     601 </span>            :     }
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : #if 0
<span class="lineNum">     604 </span>            :     {   /* Print Table (debug) */
<span class="lineNum">     605 </span>            :         U32 s;
<span class="lineNum">     606 </span>            :         U32 nTotal = 0;
<span class="lineNum">     607 </span>            :         for (s=0; s&lt;=maxSymbolValue; s++)
<span class="lineNum">     608 </span>            :             printf(&quot;%3i: %4i \n&quot;, s, normalizedCounter[s]);
<span class="lineNum">     609 </span>            :         for (s=0; s&lt;=maxSymbolValue; s++)
<span class="lineNum">     610 </span>            :             nTotal += abs(normalizedCounter[s]);
<span class="lineNum">     611 </span>            :         if (nTotal != (1U&lt;&lt;tableLog))
<span class="lineNum">     612 </span>            :             printf(&quot;Warning !!! Total == %u != %u !!!&quot;, nTotal, 1U&lt;&lt;tableLog);
<span class="lineNum">     613 </span>            :         getchar();
<span class="lineNum">     614 </span>            :     }
<span class="lineNum">     615 </span>            : #endif
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span><span class="lineCov">       8616 :     return tableLog;</span>
<span class="lineNum">     618 </span>            : }
<span class="lineNum">     619 </span>            : 
<a name="620"><span class="lineNum">     620 </span>            : </a>
<span class="lineNum">     621 </span>            : /* fake FSE_CTable, for raw (uncompressed) input */
<span class="lineNum">     622 </span><span class="lineNoCov">          0 : size_t FSE_buildCTable_raw (FSE_CTable* ct, unsigned nbBits)</span>
<span class="lineNum">     623 </span>            : {
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     const unsigned tableSize = 1 &lt;&lt; nbBits;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     const unsigned tableMask = tableSize - 1;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     const unsigned maxSymbolValue = tableMask;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :     void* const ptr = ct;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :     U16* const tableU16 = ( (U16*) ptr) + 2;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     void* const FSCT = ((U32*)ptr) + 1 /* header */ + (tableSize&gt;&gt;1);   /* assumption : tableLog &gt;= 1 */</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     FSE_symbolCompressionTransform* const symbolTT = (FSE_symbolCompressionTransform*) (FSCT);</span>
<span class="lineNum">     631 </span>            :     unsigned s;
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :     /* Sanity checks */
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     if (nbBits &lt; 1) return ERROR(GENERIC);             /* min size */</span>
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            :     /* header */
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :     tableU16[-2] = (U16) nbBits;</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     tableU16[-1] = (U16) maxSymbolValue;</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :     /* Build table */
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :     for (s=0; s&lt;tableSize; s++)</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         tableU16[s] = (U16)(tableSize + s);</span>
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :     /* Build Symbol Transformation Table */
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     {   const U32 deltaNbBits = (nbBits &lt;&lt; 16) - (1 &lt;&lt; nbBits);</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :         for (s=0; s&lt;=maxSymbolValue; s++) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :             symbolTT[s].deltaNbBits = deltaNbBits;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :             symbolTT[s].deltaFindState = s-1;</span>
<span class="lineNum">     650 </span>            :     }   }
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     654 </span>            : }
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : /* fake FSE_CTable, for rle (100% always same symbol) input */
<span class="lineNum">     657 </span><span class="lineCov">          6 : size_t FSE_buildCTable_rle (FSE_CTable* ct, BYTE symbolValue)</span>
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span><span class="lineCov">          6 :     void* ptr = ct;</span>
<span class="lineNum">     660 </span><span class="lineCov">          6 :     U16* tableU16 = ( (U16*) ptr) + 2;</span>
<span class="lineNum">     661 </span><span class="lineCov">          6 :     void* FSCTptr = (U32*)ptr + 2;</span>
<span class="lineNum">     662 </span><span class="lineCov">          6 :     FSE_symbolCompressionTransform* symbolTT = (FSE_symbolCompressionTransform*) FSCTptr;</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :     /* header */
<span class="lineNum">     665 </span><span class="lineCov">          6 :     tableU16[-2] = (U16) 0;</span>
<span class="lineNum">     666 </span><span class="lineCov">          6 :     tableU16[-1] = (U16) symbolValue;</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :     /* Build table */
<span class="lineNum">     669 </span><span class="lineCov">          6 :     tableU16[0] = 0;</span>
<span class="lineNum">     670 </span><span class="lineCov">          6 :     tableU16[1] = 0;   /* just in case */</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :     /* Build Symbol Transformation Table */
<span class="lineNum">     673 </span><span class="lineCov">          6 :     symbolTT[symbolValue].deltaNbBits = 0;</span>
<span class="lineNum">     674 </span><span class="lineCov">          6 :     symbolTT[symbolValue].deltaFindState = 0;</span>
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span><span class="lineCov">          6 :     return 0;</span>
<span class="lineNum">     677 </span>            : }
<a name="678"><span class="lineNum">     678 </span>            : </a>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineCov">       2304 : static size_t FSE_compress_usingCTable_generic (void* dst, size_t dstSize,</span>
<span class="lineNum">     681 </span>            :                            const void* src, size_t srcSize,
<span class="lineNum">     682 </span>            :                            const FSE_CTable* ct, const unsigned fast)
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span><span class="lineCov">       2304 :     const BYTE* const istart = (const BYTE*) src;</span>
<span class="lineNum">     685 </span><span class="lineCov">       2304 :     const BYTE* const iend = istart + srcSize;</span>
<span class="lineNum">     686 </span><span class="lineCov">       2304 :     const BYTE* ip=iend;</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :     BIT_CStream_t bitC;
<span class="lineNum">     690 </span>            :     FSE_CState_t CState1, CState2;
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :     /* init */
<span class="lineNum">     693 </span><span class="lineCov">       2304 :     if (srcSize &lt;= 2) return 0;</span>
<span class="lineNum">     694 </span><span class="lineCov">       2304 :     { size_t const errorCode = BIT_initCStream(&amp;bitC, dst, dstSize);</span>
<span class="lineNum">     695 </span><span class="lineCov">       2304 :       if (FSE_isError(errorCode)) return 0; }</span>
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            : #define FSE_FLUSHBITS(s)  (fast ? BIT_flushBitsFast(s) : BIT_flushBits(s))
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">       2304 :     if (srcSize &amp; 1) {</span>
<span class="lineNum">     700 </span><span class="lineCov">       2170 :         FSE_initCState2(&amp;CState1, ct, *--ip);</span>
<span class="lineNum">     701 </span><span class="lineCov">       2170 :         FSE_initCState2(&amp;CState2, ct, *--ip);</span>
<span class="lineNum">     702 </span><span class="lineCov">       2170 :         FSE_encodeSymbol(&amp;bitC, &amp;CState1, *--ip);</span>
<span class="lineNum">     703 </span><span class="lineCov">       2170 :         FSE_FLUSHBITS(&amp;bitC);</span>
<span class="lineNum">     704 </span>            :     } else {
<span class="lineNum">     705 </span><span class="lineCov">        134 :         FSE_initCState2(&amp;CState2, ct, *--ip);</span>
<span class="lineNum">     706 </span><span class="lineCov">        134 :         FSE_initCState2(&amp;CState1, ct, *--ip);</span>
<span class="lineNum">     707 </span>            :     }
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :     /* join to mod 4 */
<span class="lineNum">     710 </span><span class="lineCov">       2304 :     srcSize -= 2;</span>
<span class="lineNum">     711 </span><span class="lineCov">       2304 :     if ((sizeof(bitC.bitContainer)*8 &gt; FSE_MAX_TABLELOG*4+7 ) &amp;&amp; (srcSize &amp; 2)) {  /* test bit 2 */</span>
<span class="lineNum">     712 </span><span class="lineCov">        322 :         FSE_encodeSymbol(&amp;bitC, &amp;CState2, *--ip);</span>
<span class="lineNum">     713 </span><span class="lineCov">        322 :         FSE_encodeSymbol(&amp;bitC, &amp;CState1, *--ip);</span>
<span class="lineNum">     714 </span><span class="lineCov">        322 :         FSE_FLUSHBITS(&amp;bitC);</span>
<span class="lineNum">     715 </span>            :     }
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :     /* 2 or 4 encoding per loop */
<span class="lineNum">     718 </span><span class="lineCov">     133698 :     for ( ; ip&gt;istart ; ) {</span>
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span><span class="lineCov">     129090 :         FSE_encodeSymbol(&amp;bitC, &amp;CState2, *--ip);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :         if (sizeof(bitC.bitContainer)*8 &lt; FSE_MAX_TABLELOG*2+7 )   /* this test must be static */
<span class="lineNum">     723 </span>            :             FSE_FLUSHBITS(&amp;bitC);
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">     129090 :         FSE_encodeSymbol(&amp;bitC, &amp;CState1, *--ip);</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :         if (sizeof(bitC.bitContainer)*8 &gt; FSE_MAX_TABLELOG*4+7 ) {  /* this test must be static */
<span class="lineNum">     728 </span><span class="lineCov">     129090 :             FSE_encodeSymbol(&amp;bitC, &amp;CState2, *--ip);</span>
<span class="lineNum">     729 </span><span class="lineCov">     129090 :             FSE_encodeSymbol(&amp;bitC, &amp;CState1, *--ip);</span>
<span class="lineNum">     730 </span>            :         }
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineCov">     129090 :         FSE_FLUSHBITS(&amp;bitC);</span>
<span class="lineNum">     733 </span>            :     }
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span><span class="lineCov">       2304 :     FSE_flushCState(&amp;bitC, &amp;CState2);</span>
<span class="lineNum">     736 </span><span class="lineCov">       2304 :     FSE_flushCState(&amp;bitC, &amp;CState1);</span>
<span class="lineNum">     737 </span><span class="lineCov">       2304 :     return BIT_closeCStream(&amp;bitC);</span>
<a name="738"><span class="lineNum">     738 </span>            : }</a>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">       2304 : size_t FSE_compress_usingCTable (void* dst, size_t dstSize,</span>
<span class="lineNum">     741 </span>            :                            const void* src, size_t srcSize,
<span class="lineNum">     742 </span>            :                            const FSE_CTable* ct)
<span class="lineNum">     743 </span>            : {
<span class="lineNum">     744 </span><span class="lineCov">       2304 :     const unsigned fast = (dstSize &gt;= FSE_BLOCKBOUND(srcSize));</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineCov">       2304 :     if (fast)</span>
<span class="lineNum">     747 </span><span class="lineCov">       2304 :         return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 1);</span>
<span class="lineNum">     748 </span>            :     else
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         return FSE_compress_usingCTable_generic(dst, dstSize, src, srcSize, ct, 0);</span>
<span class="lineNum">     750 </span>            : }
<a name="751"><span class="lineNum">     751 </span>            : </a>
<span class="lineNum">     752 </span>            : 
<a name="753"><span class="lineNum">     753 </span><span class="lineCov">         74 : size_t FSE_compressBound(size_t size) { return FSE_COMPRESSBOUND(size); }</span></a>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineCov">       2304 : size_t FSE_compress2 (void* dst, size_t dstSize, const void* src, size_t srcSize, unsigned maxSymbolValue, unsigned tableLog)</span>
<span class="lineNum">     756 </span>            : {
<span class="lineNum">     757 </span><span class="lineCov">       2304 :     const BYTE* const istart = (const BYTE*) src;</span>
<span class="lineNum">     758 </span><span class="lineCov">       2304 :     const BYTE* ip = istart;</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">       2304 :     BYTE* const ostart = (BYTE*) dst;</span>
<span class="lineNum">     761 </span><span class="lineCov">       2304 :     BYTE* op = ostart;</span>
<span class="lineNum">     762 </span><span class="lineCov">       2304 :     BYTE* const oend = ostart + dstSize;</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     U32   count[FSE_MAX_SYMBOL_VALUE+1];
<span class="lineNum">     765 </span>            :     S16   norm[FSE_MAX_SYMBOL_VALUE+1];
<span class="lineNum">     766 </span>            :     CTable_max_t ct;
<span class="lineNum">     767 </span>            :     size_t errorCode;
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :     /* init conditions */
<span class="lineNum">     770 </span><span class="lineCov">       2304 :     if (srcSize &lt;= 1) return 0;  /* Uncompressible */</span>
<span class="lineNum">     771 </span><span class="lineCov">       2304 :     if (!maxSymbolValue) maxSymbolValue = FSE_MAX_SYMBOL_VALUE;</span>
<span class="lineNum">     772 </span><span class="lineCov">       2304 :     if (!tableLog) tableLog = FSE_DEFAULT_TABLELOG;</span>
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :     /* Scan input and build symbol stats */
<span class="lineNum">     775 </span><span class="lineCov">       2304 :     errorCode = FSE_count (count, &amp;maxSymbolValue, ip, srcSize);</span>
<span class="lineNum">     776 </span><span class="lineCov">       2304 :     if (FSE_isError(errorCode)) return errorCode;</span>
<span class="lineNum">     777 </span><span class="lineCov">       2304 :     if (errorCode == srcSize) return 1;</span>
<span class="lineNum">     778 </span><span class="lineCov">       2304 :     if (errorCode == 1) return 0;   /* each symbol only present once */</span>
<span class="lineNum">     779 </span><span class="lineCov">       2304 :     if (errorCode &lt; (srcSize &gt;&gt; 7)) return 0;   /* Heuristic : not compressible enough */</span>
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span><span class="lineCov">       2304 :     tableLog = FSE_optimalTableLog(tableLog, srcSize, maxSymbolValue);</span>
<span class="lineNum">     782 </span><span class="lineCov">       2304 :     errorCode = FSE_normalizeCount (norm, tableLog, count, srcSize, maxSymbolValue);</span>
<span class="lineNum">     783 </span><span class="lineCov">       2304 :     if (FSE_isError(errorCode)) return errorCode;</span>
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :     /* Write table description header */
<span class="lineNum">     786 </span><span class="lineCov">       2304 :     errorCode = FSE_writeNCount (op, oend-op, norm, maxSymbolValue, tableLog);</span>
<span class="lineNum">     787 </span><span class="lineCov">       2304 :     if (FSE_isError(errorCode)) return errorCode;</span>
<span class="lineNum">     788 </span><span class="lineCov">       2304 :     op += errorCode;</span>
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :     /* Compress */
<span class="lineNum">     791 </span><span class="lineCov">       2304 :     errorCode = FSE_buildCTable (ct, norm, maxSymbolValue, tableLog);</span>
<span class="lineNum">     792 </span><span class="lineCov">       2304 :     if (FSE_isError(errorCode)) return errorCode;</span>
<span class="lineNum">     793 </span><span class="lineCov">       2304 :     errorCode = FSE_compress_usingCTable(op, oend - op, ip, srcSize, ct);</span>
<span class="lineNum">     794 </span><span class="lineCov">       2304 :     if (errorCode == 0) return 0;   /* not enough space for compressed data */</span>
<span class="lineNum">     795 </span><span class="lineCov">       2304 :     op += errorCode;</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     /* check compressibility */
<span class="lineNum">     798 </span><span class="lineCov">       2304 :     if ( (size_t)(op-ostart) &gt;= srcSize-1 )</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineCov">       2304 :     return op-ostart;</span>
<a name="802"><span class="lineNum">     802 </span>            : }</a>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineCov">       2304 : size_t FSE_compress (void* dst, size_t dstSize, const void* src, size_t srcSize)</span>
<span class="lineNum">     805 </span>            : {
<span class="lineNum">     806 </span><span class="lineCov">       2304 :     return FSE_compress2(dst, dstSize, src, (U32)srcSize, FSE_MAX_SYMBOL_VALUE, FSE_DEFAULT_TABLELOG);</span>
<span class="lineNum">     807 </span>            : }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : #endif   /* FSE_COMMONDEFS_ONLY */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
